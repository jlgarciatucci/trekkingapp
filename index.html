<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OSM Route Planner — BRouter + Robust Elevation</title>

<!-- Your original CDNs (kept) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@7.1.0/turf.min.js"></script>

<style>
  html,body,#map{height:100%;margin:0}
  #map{position:relative}

  .ui{
    position:absolute;top:10px;left:10px;z-index:9999;
    background:#111827;color:#e5e7eb;padding:10px 12px;border-radius:12px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto; box-shadow:0 6px 20px rgba(0,0,0,.35)
  }
  .ui *{font-size:14px}
  .ui select,.ui button,.ui input{
    background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;
    padding:8px 10px;margin-right:6px; outline:none
  }
  .row{margin-top:8px}
  .ok{color:#86efac}.warn{color:#fde68a}.err{color:#fca5a5}
  .badge{background:#0b1220;border:1px solid #334155;border-radius:999px;padding:6px 10px;margin-left:8px}

  /* Elevation panel (desktop defaults) */
  #elevWrap{
    position:absolute;left:10px;right:10px;bottom:10px;z-index:9998;
    background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:12px;
    padding:10px 12px;box-shadow:0 6px 20px rgba(0,0,0,.35);
    transition:height .18s ease, transform .18s ease, opacity .18s ease;
  }
  #elevHeader{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  #elevHeader .stat{background:#111827;border:1px solid #334155;border-radius:10px;padding:4px 8px}
  #elevChart{width:100%;height:160px;display:block;margin-top:8px;background:#091018;border-radius:8px}
  #elevHint{opacity:.75;font-size:12px;margin-left:auto}

  /* Toggle button for elevation (mobile sheet) */
  #toggleElev{
    position:absolute; right:12px; bottom:12px; z-index:9999;
    width:48px; height:48px; border-radius:999px; display:flex; align-items:center; justify-content:center;
    background:#111827; color:#e5e7eb; border:1px solid #334155;
    box-shadow:0 6px 20px rgba(0,0,0,.35); cursor:pointer; user-select:none;
    display:none; /* desktop hidden; shown on mobile */
  }

  /* Layers control (dark UI) */
  .leaflet-control-layers{
    border-radius:12px; overflow:hidden;
    background:#111827; color:#e5e7eb; border:1px solid #334155;
  }
  .leaflet-control-layers-expanded{
    background:#111827; color:#e5e7eb;
  }
  .leaflet-control-layers-list label{ color:#e5e7eb; }

  /* ---------- Mobile layout tweaks ---------- */
  @media (max-width: 768px){
    .ui{
      left:8px; right:8px; top:8px;
      padding:8px 10px; max-width:unset
    }
    .ui select,.ui button,.ui input{
      padding:6px 8px; margin-right:4px; font-size:13px;
    }
    .badge{padding:4px 8px}

    /* Turn elevation into a bottom sheet */
    #elevWrap{
      left:0; right:0; bottom:0; border-radius:12px 12px 0 0;
      padding:10px 12px 12px 12px;
      max-height:60vh;   /* never cover too much */
      overflow:hidden;
      opacity:0; transform:translateY(8px); pointer-events:none; /* collapsed by default */
    }
    #elevWrap.open{
      opacity:1; transform:translateY(0); pointer-events:auto;
    }
    /* Shorter chart on mobile */
    #elevChart{ height:140px; }

    /* Show the toggle FAB on mobile */
    #toggleElev{ display:flex; }

    /* Hide Leaflet’s built-in layers control on mobile (we use our dropdown) */
    .leaflet-control-layers { display:none !important; }
  }
</style>
</head>
<body>
<div id="map"></div>

<div class="ui">
  <div class="row">
    <b>BRouter profile</b>
    <select id="profile">
      <option value="hiking">hiking (prefers trails)</option>
      <option value="foot">foot (pedestrian)</option>
      <option value="trekking">trekking (bike/hike mix)</option>
    </select>
    <span id="dist" class="badge">0.00 km</span>

    <!-- Basemap dropdown (mobile-friendly, always visible) -->
    <label style="margin-left:8px">
      Basemap
      <select id="basemapSel">
        <option value="osm">OSM</option>
        <option value="sat">Satellite</option>
        <option value="topo">Topo</option>
        <option value="dark">Dark</option>
      </select>
    </label>
  </div>
  <div class="row">
    <input id="routeName" placeholder="Route name" size="16" />
    <button id="btnGpx">Export GPX</button>
    <button id="btnKml">KML</button>
    <button id="btnGeo">GeoJSON</button>
    <button id="btnClear">Clear</button>
    <span id="status" class="ok">click/tap to add Start → End → Via… (drag markers; long-press/right-click to remove)</span>
  </div>
</div>

<!-- mobile toggle for elevation -->
<div id="toggleElev" title="Show/hide elevation">⌄</div>

<!-- Elevation panel -->
<div id="elevWrap" style="display:none">
  <div id="elevHeader">
    <strong>Elevation profile</strong>
    <span class="stat" id="statMin">Min: —</span>
    <span class="stat" id="statMax">Max: —</span>
    <span class="stat" id="statGain">Ascent: —</span>
    <span class="stat" id="statLoss">Descent: —</span>

    <label style="margin-left:12px">Smoothing
      <select id="smoothLevel">
        <option value="none">None</option>
        <option value="low" selected>Low</option>
        <option value="med">Medium</option>
        <option value="high">High</option>
      </select>
    </label>

    <span id="elevHint">hover/drag on chart to see values</span>
  </div>
  <svg id="elevChart"></svg>
</div>

<script>
/* ============== Map ============== */
const map = L.map('map').setView([41.387, 2.170], 12);

// --- Base maps ---
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 20, attribution: '© OpenStreetMap contributors'
});
const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20, attribution: 'Tiles © Esri — Sources: Esri, USGS, IGN, etc.'
});
const esriLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20, attribution: 'Labels © Esri'
});
const openTopo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
  maxZoom: 17, attribution: '© OpenStreetMap, SRTM — OpenTopoMap (CC-BY-SA)'
});
const cartoDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  maxZoom: 20, attribution: '© OpenStreetMap, © CARTO'
});
osm.addTo(map);

const baseLayers = {
  "OSM Standard": osm,
  "Esri Satellite": esriSat,
  "OpenTopoMap": openTopo,
  "CARTO Dark": cartoDark
};
const overlays = { "Labels (Esri)": esriLabels };

L.control.layers(baseLayers, overlays, { position: 'topright', collapsed: true }).addTo(map);

// Auto-show labels with satellite when using Leaflet control
map.on('baselayerchange', (e) => {
  if (e.name === 'Esri Satellite' && !map.hasLayer(esriLabels)) esriLabels.addTo(map);
  if (e.name !== 'Esri Satellite' && map.hasLayer(esriLabels)) esriLabels.remove();
});

// ---- Basemap dropdown control (mobile-friendly) ----
const basemapSel = document.getElementById('basemapSel');
let currentBase = osm; // default added first
function setBasemap(key){
  if (currentBase) map.removeLayer(currentBase);

  if (key === 'osm') {
    currentBase = osm;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  } else if (key === 'sat') {
    currentBase = esriSat;
    if (!map.hasLayer(esriLabels)) esriLabels.addTo(map);
  } else if (key === 'topo') {
    currentBase = openTopo;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  } else if (key === 'dark') {
    currentBase = cartoDark;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  } else {
    currentBase = osm;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  }
  currentBase.addTo(map);
}
// initialize dropdown to match current layer (osm by default)
if (basemapSel) {
  basemapSel.value = 'osm';
  basemapSel.addEventListener('change', (e)=> setBasemap(e.target.value));
}
// keep dropdown in sync if user uses desktop Layers control
map.on('baselayerchange', (e) => {
  const name = e.name || '';
  if (!basemapSel) return;
  if (name.includes('OSM')) basemapSel.value = 'osm';
  else if (name.includes('Satellite')) basemapSel.value = 'sat';
  else if (name.includes('OpenTopo')) basemapSel.value = 'topo';
  else if (name.includes('CARTO Dark')) basemapSel.value = 'dark';
});

const profileSel = document.getElementById('profile');
const distBadge  = document.getElementById('dist');
const statusEl   = document.getElementById('status');
const routeName  = document.getElementById('routeName');
const toggleElev = document.getElementById('toggleElev');
const elevWrap   = document.getElementById('elevWrap');
const elevChart  = document.getElementById('elevChart');

function status(msg, cls='ok'){ statusEl.className = cls; statusEl.textContent = msg; }

/* ============== Waypoints & markers ============== */
let waypoints = [];        // array of L.LatLng
let markersLayer = L.layerGroup().addTo(map);
let routeLayer   = null;   // L.GeoJSON of the route
let currentGeo   = null;   // GeoJSON FeatureCollection of the route

map.on('click', (e)=> addWaypoint(e.latlng));

function addWaypoint(latlng){
  waypoints.push(latlng);
  redrawMarkers();
  if(waypoints.length >= 2) computeRoute();
}

function redrawMarkers(){
  markersLayer.clearLayers();
  waypoints.forEach((ll, idx)=>{
    const label = (idx===0?'Start': (idx===waypoints.length-1?'End':'Via'));
    const m = L.marker(ll, { draggable:true, title:label }).addTo(markersLayer);
    m.bindTooltip(label, {permanent:true, direction:'top', offset:[0,-12]});
    m.on('dragend', (ev)=>{ waypoints[idx] = ev.target.getLatLng(); computeRoute(); });
    m.on('contextmenu', ()=>{ // right-click to remove a waypoint (long-press on mobile)
      waypoints.splice(idx,1);
      redrawMarkers();
      if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; currentGeo = null; }
      hideElevation();
      if(waypoints.length >= 2) computeRoute(); else updateDistance(0);
    });
  });
}

document.getElementById('btnClear').onclick = ()=>{
  waypoints = [];
  redrawMarkers();
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation();
  updateDistance(0);
  status('cleared','ok');
};

/* ============== Routing (BRouter first, OSRM foot fallback) ============== */
async function computeRoute(){
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation();
  status('routing with BRouter…','warn');

  try{
    const geo = await fetchBRouterGeoJSON(waypoints, profileSel.value);
    drawRouteGeoJSON(geo);
    status('ok (BRouter)','ok');
    await buildElevation(geo);
  }catch(err){
    console.warn('BRouter failed:', err);
    status('BRouter failed → trying OSRM foot…','warn');
    try{
      const geo = await fetchOSRMFootGeoJSON(waypoints);
      drawRouteGeoJSON(geo);
      status('ok (OSRM foot fallback)','ok');
      await buildElevation(geo);
    }catch(e2){
      console.error('OSRM fallback failed:', e2);
      status('routing failed on all services','err');
    }
  }
}

function encodeLonLats(pts){
  // BRouter expects lon,lat pairs bar-separated
  return pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join('|');
}

async function fetchBRouterGeoJSON(pts, profile){
  const lonlats = encodeLonLats(pts);
  const url = `https://brouter.de/brouter?lonlats=${encodeURIComponent(lonlats)}&profile=${encodeURIComponent(profile)}&alternativeidx=0&format=geojson`;
  const r = await fetch(url, { method:'GET' });
  if(!r.ok) throw new Error('HTTP '+r.status);
  return await r.json(); // FeatureCollection
}

async function fetchOSRMFootGeoJSON(pts){
  const coords = pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join(';');
  const url = `https://routing.openstreetmap.de/routed-foot/route/v1/foot/${coords}?overview=full&geometries=geojson&steps=false&alternatives=false`;
  const r = await fetch(url, { method:'GET' });
  const j = await r.json().catch(()=>null);
  if(!r.ok || !j || !j.routes || !j.routes.length) throw new Error('OSRM foot error');
  const line = j.routes[0].geometry; // GeoJSON LineString
  return { type:'FeatureCollection', features:[{ type:'Feature', properties:{source:'osrm-foot'}, geometry: line }] };
}

/* ============== Draw + distance + fit ============== */
function drawRouteGeoJSON(geo){
  currentGeo = geo;
  if(routeLayer){ map.removeLayer(routeLayer); }
  routeLayer = L.geoJSON(geo, { style: { color:'#22c55e', weight:5, opacity:0.95 } }).addTo(map);
  try { map.fitBounds(routeLayer.getBounds(), { padding:[20,20] }); } catch(_) {}
  const merged = mergeToLineString(geo);
  const km = merged ? turf.length(merged, {units:'kilometers'}) : 0;
  updateDistance(km);
}

function mergeToLineString(fc){
  if(!fc || !fc.features) return null;
  const coords = [];
  fc.features.forEach(f=>{
    if(!f.geometry) return;
    if(f.geometry.type==='LineString') coords.push(...f.geometry.coordinates);
    if(f.geometry.type==='MultiLineString') f.geometry.coordinates.forEach(c=>coords.push(...c));
  });
  return coords.length ? { type:'Feature', geometry:{ type:'LineString', coordinates: coords }, properties:{} } : null;
}

function updateDistance(km){
  distBadge.textContent = `${(km||0).toFixed(2)} km`;
}

/* ============== Elevation profile (robust) ============== */
const statMin    = document.getElementById('statMin');
const statMax    = document.getElementById('statMax');
const statGain   = document.getElementById('statGain');
const statLoss   = document.getElementById('statLoss');
const smoothSel  = document.getElementById('smoothLevel');

function hideElevation(){
  elevWrap.style.display = 'none';
  elevWrap.classList.remove('open');
  elevChart.innerHTML = '';
  toggleElev.textContent = '⌃';
}

// simple median filter (odd window)
function medianFilter(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null).sort((x,y)=>x-y);
    out[i] = slice.length ? slice[Math.floor(slice.length/2)] : arr[i];
  }
  return out;
}
// centered moving average (odd window)
function movingAverage(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null);
    const sum = slice.reduce((s,v)=>s+v,0);
    out[i] = slice.length ? (sum/slice.length) : arr[i];
  }
  return out;
}
function smoothSeries(raw, level){
  if(level==='none') return raw.slice();
  const cfg = {
    low:  { med:5, avg:7  },
    med:  { med:5, avg:11 },
    high: { med:7, avg:15 }
  }[level] || { med:5, avg:7 };
  const m = medianFilter(raw, cfg.med);
  return movingAverage(m, cfg.avg);
}

smoothSel.addEventListener('change', ()=> {
  if(current_elev_cache){
    renderElevation(current_elev_cache.latlngs, current_elev_cache.elevs); // re-render with new smoothing
  }
});

let current_elev_cache = null;

// Helper: detect if route roughly lies in Europe to pick EU-DEM
function routeInEurope(lineFeature){
  // rough Europe bbox [W,S,E,N]
  const EUROPE_BBOX = [-31.5, 27.5, 45.5, 71.5];
  try {
    const bb = turf.bbox(lineFeature); // [minX, minY, maxX, maxY]
    const cx = (bb[0] + bb[2]) / 2, cy = (bb[1] + bb[3]) / 2;
    return (cx >= EUROPE_BBOX[0] && cx <= EUROPE_BBOX[2] &&
            cy >= EUROPE_BBOX[1] && cy <= EUROPE_BBOX[3]);
  } catch { return false; }
}

async function buildElevation(geo){
  try{
    const line = mergeToLineString(geo);
    if(!line) { hideElevation(); return; }

    const lengthKm = turf.length(line, {units:'kilometers'});

    // modest sampling: ~20 pts/km (cap 250) → fewer rate limits and shorter URLs
    const samples = Math.max(30, Math.min(250, Math.round(lengthKm * 20)));

    const pts = [];
    for (let i=0;i<=samples;i++){
      const seg = turf.along(line, (lengthKm * i / samples), {units:'kilometers'});
      const [x,y] = seg.geometry.coordinates;
      pts.push([y,x]); // lat,lon
    }

    // Choose dataset: EU → eudem25m, otherwise srtm90m
    const dataset = routeInEurope(line) ? 'eudem25m' : 'srtm90m';

    const elevations = await fetchElevationsRobust(pts, dataset);

    if (!elevations || elevations.every(v => v == null)){
      status('Elevation unavailable (all providers failed)', 'warn');
      hideElevation();
      return;
    }

    current_elev_cache = { latlngs: pts, elevs: elevations };
    renderElevation(pts, elevations);

    // show panel now (desktop visible; mobile starts opened a bit)
    elevWrap.style.display = 'block';
    if (window.matchMedia('(max-width: 768px)').matches){
      elevWrap.classList.add('open');
      toggleElev.textContent = '⌄';
    }
  }catch(err){
    console.warn('Elevation failed:', err);
    status('Elevation error (see console)', 'warn');
    hideElevation();
  }
}

// Robust fetch: OpenTopoData first (batched, cubic), fallback to Open-Elevation (batched).
async function fetchElevationsRobust(latlngs, dataset='srtm90m'){
  try {
    const vals = await fetchOpenTopoData(latlngs, dataset);
    if (vals && vals.some(v => v != null)) return vals;
  } catch (e) {
    console.warn('OpenTopoData error:', e);
  }
  try {
    const vals2 = await fetchOpenElevation(latlngs);
    return vals2;
  } catch (e2) {
    console.warn('Open-Elevation error:', e2);
  }
  return new Array(latlngs.length).fill(null);
}

async function fetchOpenTopoData(latlngs, dataset){
  const BATCH = 80; // keep URLs short/reliable
  const out = [];
  for (let i=0; i<latlngs.length; i+=BATCH){
    const chunk = latlngs.slice(i, i+BATCH)
      .map(([lat,lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join('|');
    const url = `https://api.opentopodata.org/v1/${dataset}` +
                `?locations=${encodeURIComponent(chunk)}&interpolation=cubic`;
    const r = await fetch(url);
    const j = await r.json().catch(()=>null);
    if (!r.ok || !j || !j.results) throw new Error(`OpenTopoData ${r.status}`);
    j.results.forEach(res => out.push(res ? res.elevation : null));
  }
  return out;
}

async function fetchOpenElevation(latlngs){
  const BATCH = 100;
  const out = [];
  for (let i=0; i<latlngs.length; i+=BATCH){
    const chunk = latlngs.slice(i, i+BATCH)
      .map(([lat,lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join('|');
    const url = `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(chunk)}`;
    const r = await fetch(url);
    const j = await r.json().catch(()=>null);
    if (!r.ok || !j || !j.results) throw new Error(`Open-Elevation ${r.status}`);
    j.results.forEach(res => out.push(res ? res.elevation : null));
  }
  return out;
}

function renderElevation(latlngs, elevsRaw){
  if(!elevsRaw || !elevsRaw.length) return hideElevation();

  // smooth it
  const level = smoothSel.value;
  const elevs = smoothSeries(elevsRaw, level);

  // Compute stats on smoothed series
  let min = Infinity, max = -Infinity, gain = 0, loss = 0;
  for(let i=0;i<elevs.length;i++){
    const z = elevs[i]; if(z==null) continue;
    if(z<min) min = z; if(z>max) max = z;
    if(i>0 && elevs[i-1]!=null){
      const dz = z - elevs[i-1];
      if(dz>0) gain += dz; else loss += -dz;
    }
  }

  statMin.textContent  = `Min: ${Math.round(min)} m`;
  statMax.textContent  = `Max: ${Math.round(max)} m`;
  statGain.textContent = `Ascent: ${Math.round(gain)} m`;
  statLoss.textContent = `Descent: ${Math.round(loss)} m`;

  // Build SVG
  const W = elevChart.clientWidth || 600;
  const H = elevChart.clientHeight || 160;
  const pad = 24;
  const w = W - pad*2;
  const h = H - pad*2;

  const eMin = Math.min(min, max-1);
  const eMax = max;
  const scaleX = (i)=> pad + (i/(elevs.length-1))*w;
  const scaleY = (z)=> pad + h - ((z - eMin) / (eMax - eMin || 1)) * h;

  // Path
  let d = '';
  for(let i=0;i<elevs.length;i++){
    const x = scaleX(i), y = scaleY(elevs[i]);
    d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
  }
  const area = `${d} L ${pad + w} ${pad + h} L ${pad} ${pad + h} Z`;

  // Axis ticks
  const ticks = [eMin, (eMin+eMax)/2, eMax];

  elevChart.innerHTML = `
    <defs>
      <linearGradient id="grad" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#22c55e" stop-opacity="0.35"/>
        <stop offset="100%" stop-color="#22c55e" stop-opacity="0.05"/>
      </linearGradient>
    </defs>
    <rect x="0" y="0" width="${W}" height="${H}" fill="transparent"/>
    <path d="${area}" fill="url(#grad)"></path>
    <path d="${d}" fill="none" stroke="#22c55e" stroke-width="2"></path>
    ${ticks.map((t,i)=>{
      const y = scaleY(t);
      return `<line x1="${pad}" y1="${y}" x2="${pad+w}" y2="${y}" stroke="#223" stroke-dasharray="3,3"/>
              <text x="${pad-6}" y="${y+4}" text-anchor="end" fill="#9ca3af" font-size="11">${Math.round(t)} m</text>`;
    }).join('')}
  `;

  // Hover/Touch tooltip
  const tooltip = document.createElementNS('http://www.w3.org/2000/svg','g');
  const line   = document.createElementNS('http://www.w3.org/2000/svg','line');
  const dot    = document.createElementNS('http://www.w3.org/2000/svg','circle');
  const label  = document.createElementNS('http://www.w3.org/2000/svg','text');
  line.setAttribute('stroke','#93c5fd'); line.setAttribute('y1', pad); line.setAttribute('y2', pad+h);
  dot.setAttribute('r','3'); dot.setAttribute('fill','#93c5fd'); dot.setAttribute('stroke','#111827');
  label.setAttribute('fill','#e5e7eb'); label.setAttribute('font-size','11');
  tooltip.appendChild(line); tooltip.appendChild(dot); tooltip.appendChild(label);
  elevChart.appendChild(tooltip);
  tooltip.style.display = 'none';

  function nearestIndex(mouseX){
    const x = Math.max(pad, Math.min(mouseX, pad+w));
    const ratio = (x - pad)/w;
    return Math.round(ratio * (elevs.length-1));
  }

  function updateTip(evt){
    const rect = elevChart.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const x = clientX - rect.left;
    const i = nearestIndex(x);
    const xi = scaleX(i), yi = scaleY(elevs[i]);
    tooltip.style.display = '';
    line.setAttribute('x1', xi); line.setAttribute('x2', xi);
    dot.setAttribute('cx', xi);  dot.setAttribute('cy', yi);
    label.setAttribute('x', xi+6); label.setAttribute('y', yi-8);
    const distTotal = turf.length(mergeToLineString(currentGeo), {units:'kilometers'}) || 0;
    const distAt = (distTotal * (i/(elevs.length-1)));
    label.textContent = `${Math.round(elevs[i])} m @ ${distAt.toFixed(2)} km`;
  }

  elevChart.onmousemove = updateTip;
  elevChart.ontouchstart = updateTip;
  elevChart.ontouchmove = updateTip;
  elevChart.onmouseleave = ()=>{ tooltip.style.display = 'none'; };
}

/* ============== Profile change triggers re-route ============== */
profileSel.addEventListener('change', ()=>{ if(waypoints.length>=2) computeRoute(); });

/* ============== Exporters ============== */
const btnGpx = document.getElementById('btnGpx');
const btnKml = document.getElementById('btnKml');
const btnGeo = document.getElementById('btnGeo');

btnGeo.addEventListener('click', ()=>{
  if(!currentGeo){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.geojson';
  download(name, JSON.stringify(currentGeo, null, 2), 'application/geo+json');
});

btnGpx.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.gpx';
  const gpx = toGPX(line, current_elev_cache);
  download(name, gpx, 'application/gpx+xml');
});

btnKml.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.kml';
  const kml = toKML(line, current_elev_cache);
  download(name, kml, 'application/vnd.google-earth.kml+xml');
});

function download(filename, data, mime='application/octet-stream'){
  const blob = new Blob([data], {type:mime});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

function toGPX(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    elevs = resampleArray(elevCache.elevs, coords.length); // resample to match
  }
  const name = escapeXml(routeName.value || 'Route');
  const trkpts = coords.map((c,i)=>{
    const lon = c[0].toFixed(6), lat = c[1].toFixed(6);
    const ele = elevs ? `<ele>${Number(elevs[i]).toFixed(1)}</ele>` : '';
    return `<trkpt lat="${lat}" lon="${lon}">${ele}</trkpt>`;
  }).join('');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Leaflet+BRouter" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><name>${name}</name></metadata>
  <trk><name>${name}</name><trkseg>${trkpts}</trkseg></trk>
</gpx>`;
}

function toKML(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    elevs = resampleArray(elevCache.elevs, coords.length);
  }
  const name = escapeXml(routeName.value || 'Route');
  const coordStr = coords.map((c,i)=>{
    const z = elevs ? Number(elevs[i]).toFixed(1) : '0';
    return `${c[0].toFixed(6)},${c[1].toFixed(6)},${z}`;
  }).join(' ');
  return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Placemark>
      <name>${name}</name>
      <Style><LineStyle><color>ff55c522</color><width>4</width></LineStyle></Style>
      <LineString><tessellate>1</tessellate><coordinates>${coordStr}</coordinates></LineString>
    </Placemark>
  </Document>
</kml>`;
}

function resampleArray(arr, n){
  // simple linear resample from arr.length -> n
  const out = new Array(n);
  const m = arr.length;
  for(let i=0;i<n;i++){
    const t = (i*(m-1))/(n-1);
    const i0 = Math.floor(t), i1 = Math.min(m-1, i0+1);
    const a = arr[i0], b = arr[i1];
    const frac = t - i0;
    out[i] = a + (b - a) * frac;
  }
  return out;
}

function escapeXml(s){ return String(s).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c])); }

/* ============== Mobile: elevation toggle ============== */
toggleElev.addEventListener('click', ()=>{
  if (elevWrap.style.display === 'none') return; // nothing to show
  elevWrap.classList.toggle('open');
  toggleElev.textContent = elevWrap.classList.contains('open') ? '⌄' : '⌃';
  // reflow chart after transition
  setTimeout(()=>{ if(current_elev_cache) renderElevation(current_elev_cache.latlngs, current_elev_cache.elevs); }, 220);
});
</script>
</body>
</html>
