<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OSM Route Planner — BRouter + High-Accuracy Elevation</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@7.1.0/turf.min.js"></script>

<style>
  html,body,#map{height:100%;margin:0}
  .ui{
    position:absolute;top:10px;left:10px;z-index:9999;
    background:#111827;color:#e5e7eb;padding:10px 12px;border-radius:12px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto; box-shadow:0 6px 20px rgba(0,0,0,.35)
  }
  .ui *{font-size:14px}
  .ui select,.ui button,.ui input{
    background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;
    padding:8px 10px;margin-right:6px; outline:none
  }
  .row{margin-top:8px}
  .ok{color:#86efac}.warn{color:#fde68a}.err{color:#fca5a5}
  .badge{background:#0b1220;border:1px solid #334155;border-radius:999px;padding:6px 10px;margin-left:8px}
  .tip{opacity:.85;margin-left:6px}

  /* Elevation panel */
  #elevWrap{
    position:absolute;left:10px;right:10px;bottom:10px;z-index:9998;
    background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:12px;
    padding:10px 12px;box-shadow:0 6px 20px rgba(0,0,0,.35)
  }
  #elevHeader{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  #elevHeader .stat{background:#111827;border:1px solid #334155;border-radius:10px;padding:4px 8px}
  #elevChart{width:100%;height:160px;display:block;margin-top:8px;background:#091018;border-radius:8px}
  #elevHint{opacity:.75;font-size:12px;margin-left:auto}

  /* Leaflet control (for better contrast) */
  .leaflet-control-layers{
    border-radius:12px; overflow:hidden;
    background:#111827; color:#e5e7eb; border:1px solid #334155;
  }
  .leaflet-control-layers-expanded{
    background:#111827; color:#e5e7eb;
  }
  .leaflet-control-layers-list label{ color:#e5e7eb; }
</style>
</head>
<body>
<div id="map"></div>

<div class="ui">
  <div class="row">
    <b>BRouter profile</b>
    <select id="profile">
      <option value="hiking">hiking (prefers trails)</option>
      <option value="foot">foot (pedestrian)</option>
      <option value="trekking">trekking (bike/hike mix)</option>
    </select>
    <span id="dist" class="badge">0.00 km</span>
  </div>
  <div class="row">
    <input id="routeName" placeholder="Route name" size="16" />
    <button id="btnGpx">Export GPX</button>
    <button id="btnKml">KML</button>
    <button id="btnGeo">GeoJSON</button>
    <button id="btnClear">Clear</button>
    <span id="status" class="ok">click to add Start → End → Via… (drag markers)</span>
  </div>
</div>

<!-- Elevation panel -->
<div id="elevWrap" style="display:none">
  <div id="elevHeader">
    <strong>Elevation profile</strong>
    <span class="stat" id="statMin">Min: —</span>
    <span class="stat" id="statMax">Max: —</span>
    <span class="stat" id="statGain">Ascent: —</span>
    <span class="stat" id="statLoss">Descent: —</span>

    <label style="margin-left:12px">Smoothing
      <select id="smoothLevel">
        <option value="none">None</option>
        <option value="low" selected>Low</option>
        <option value="med">Medium</option>
        <option value="high">High</option>
      </select>
    </label>

    <span id="elevHint">hover the chart to see values</span>
  </div>
  <svg id="elevChart"></svg>
</div>

<script>
/* ============== Map ============== */
const map = L.map('map').setView([41.387, 2.170], 12);

// --- Base maps ---
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 20,
  attribution: '© OpenStreetMap contributors'
});
const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20,
  attribution: 'Tiles © Esri — Sources: Esri, i-cubed, USDA, USGS, IGN, etc.'
});
const esriLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20, attribution: 'Labels © Esri'
});
const openTopo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
  maxZoom: 17,
  attribution: '© OpenStreetMap, SRTM — OpenTopoMap (CC-BY-SA)'
});
const cartoDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  maxZoom: 20, attribution: '© OpenStreetMap, © CARTO'
});
osm.addTo(map);

// Layer control
const baseLayers = {
  "OSM Standard": osm,
  "Esri Satellite": esriSat,
  "OpenTopoMap": openTopo,
  "CARTO Dark": cartoDark
};
const overlays = {
  "Labels (Esri)": esriLabels
};
L.control.layers(baseLayers, overlays, { position: 'topright', collapsed: true }).addTo(map);

// Auto-show labels over satellite
map.on('baselayerchange', (e) => {
  if (e.name === 'Esri Satellite') {
    if (!map.hasLayer(esriLabels)) esriLabels.addTo(map);
  }
});

const profileSel = document.getElementById('profile');
const distBadge  = document.getElementById('dist');
const statusEl   = document.getElementById('status');
const routeName  = document.getElementById('routeName');

function status(msg, cls='ok'){ statusEl.className = cls; statusEl.textContent = msg; }

/* ============== Waypoints & markers ============== */
let waypoints = [];        // array of L.LatLng
let markersLayer = L.layerGroup().addTo(map);
let routeLayer   = null;   // L.GeoJSON of the route
let currentGeo   = null;   // GeoJSON FeatureCollection of the route

map.on('click', (e)=> addWaypoint(e.latlng));

function addWaypoint(latlng){
  waypoints.push(latlng);
  redrawMarkers();
  if(waypoints.length >= 2) computeRoute();
}

function redrawMarkers(){
  markersLayer.clearLayers();
  waypoints.forEach((ll, idx)=>{
    const label = (idx===0?'Start': (idx===waypoints.length-1?'End':'Via'));
    const m = L.marker(ll, { draggable:true, title:label }).addTo(markersLayer);
    m.bindTooltip(label, {permanent:true, direction:'top', offset:[0,-12]});
    m.on('dragend', (ev)=>{ waypoints[idx] = ev.target.getLatLng(); computeRoute(); });
    m.on('contextmenu', ()=>{ // right-click to remove a waypoint
      waypoints.splice(idx,1);
      redrawMarkers();
      if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; currentGeo = null; }
      hideElevation();
      if(waypoints.length >= 2) computeRoute(); else updateDistance(0);
    });
  });
}

document.getElementById('btnClear').onclick = ()=>{
  waypoints = [];
  redrawMarkers();
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation();
  updateDistance(0);
  status('cleared','ok');
};

/* ============== Routing (BRouter first, OSRM foot fallback) ============== */
async function computeRoute(){
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation();
  status('routing with BRouter…','warn');

  try{
    const geo = await fetchBRouterGeoJSON(waypoints, profileSel.value);
    drawRouteGeoJSON(geo);
    status('ok (BRouter)','ok');
    buildElevation(geo);
  }catch(err){
    console.warn('BRouter failed:', err);
    status('BRouter failed → trying OSRM foot…','warn');
    try{
      const geo = await fetchOSRMFootGeoJSON(waypoints);
      drawRouteGeoJSON(geo);
      status('ok (OSRM foot fallback)','ok');
      buildElevation(geo);
    }catch(e2){
      console.error('OSRM fallback failed:', e2);
      status('routing failed on all services','err');
    }
  }
}

function encodeLonLats(pts){
  // BRouter expects lon,lat pairs bar-separated
  return pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join('|');
}

async function fetchBRouterGeoJSON(pts, profile){
  const lonlats = encodeLonLats(pts);
  const url = `https://brouter.de/brouter?lonlats=${encodeURIComponent(lonlats)}&profile=${encodeURIComponent(profile)}&alternativeidx=0&format=geojson`;
  const r = await fetch(url, { method:'GET' });
  if(!r.ok) throw new Error('HTTP '+r.status);
  return await r.json(); // FeatureCollection
}

async function fetchOSRMFootGeoJSON(pts){
  const coords = pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join(';');
  const url = `https://routing.openstreetmap.de/routed-foot/route/v1/foot/${coords}?overview=full&geometries=geojson&steps=false&alternatives=false`;
  const r = await fetch(url, { method:'GET' });
  const j = await r.json().catch(()=>null);
  if(!r.ok || !j || !j.routes || !j.routes.length) throw new Error('OSRM foot error');
  const line = j.routes[0].geometry; // GeoJSON LineString
  return { type:'FeatureCollection', features:[{ type:'Feature', properties:{source:'osrm-foot'}, geometry: line }] };
}

/* ============== Draw + distance + fit ============== */
function drawRouteGeoJSON(geo){
  currentGeo = geo;
  if(routeLayer){ map.removeLayer(routeLayer); }
  routeLayer = L.geoJSON(geo, { style: { color:'#22c55e', weight:5, opacity:0.95 } }).addTo(map);
  try { map.fitBounds(routeLayer.getBounds(), { padding:[20,20] }); } catch(_) {}
  const merged = mergeToLineString(geo);
  const km = merged ? turf.length(merged, {units:'kilometers'}) : 0;
  updateDistance(km);
}

function mergeToLineString(fc){
  if(!fc || !fc.features) return null;
  const coords = [];
  fc.features.forEach(f=>{
    if(!f.geometry) return;
    if(f.geometry.type==='LineString') coords.push(...f.geometry.coordinates);
    if(f.geometry.type==='MultiLineString') f.geometry.coordinates.forEach(c=>coords.push(...c));
  });
  return coords.length ? { type:'Feature', geometry:{ type:'LineString', coordinates: coords }, properties:{} } : null;
}

function updateDistance(km){
  distBadge.textContent = `${(km||0).toFixed(2)} km`;
}

/* ============== Elevation profile (high-accuracy) ============== */
const elevWrap   = document.getElementById('elevWrap');
const elevChart  = document.getElementById('elevChart');
const statMin    = document.getElementById('statMin');
const statMax    = document.getElementById('statMax');
const statGain   = document.getElementById('statGain');
const statLoss   = document.getElementById('statLoss');
const smoothSel  = document.getElementById('smoothLevel');

function hideElevation(){ elevWrap.style.display = 'none'; elevChart.innerHTML = ''; }

// simple median filter (odd window)
function medianFilter(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null).sort((x,y)=>x-y);
    out[i] = slice.length ? slice[Math.floor(slice.length/2)] : arr[i];
  }
  return out;
}
// centered moving average (odd window)
function movingAverage(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null);
    const sum = slice.reduce((s,v)=>s+v,0);
    out[i] = slice.length ? (sum/slice.length) : arr[i];
  }
  return out;
}
function smoothSeries(raw, level){
  if(level==='none') return raw.slice();
  const cfg = {
    low: { med:5, avg:7 },
    med: { med:5, avg:11 },
    high:{ med:7, avg:15 }
  }[level] || { med:5, avg:7 };
  const m = medianFilter(raw, cfg.med);
  return movingAverage(m, cfg.avg);
}

smoothSel.addEventListener('change', ()=> {
  if(current_elev_cache){
    renderElevation(current_elev_cache.latlngs, current_elev_cache.elevs); // re-render with new smoothing
  }
});

let current_elev_cache = null;

async function buildElevation(geo){
  try{
    const line = mergeToLineString(geo);
    if(!line) return hideElevation();

    // denser sampling: ~50 points/km, cap at 450
    const lengthKm = turf.length(line, {units:'kilometers'});
    const samples  = Math.max(30, Math.min(450, Math.round(lengthKm * 50)));
    const pts = [];
    for(let i=0;i<=samples;i++){
      const seg = turf.along(line, (lengthKm * i / samples), {units:'kilometers'});
      const [x,y] = seg.geometry.coordinates;
      pts.push([y,x]); // lat,lon
    }

    // High-accuracy: EU-DEM 25m with SRTM fallback, cubic interpolation
    const elevations = await fetchElevationsOpenTopo(pts);

    current_elev_cache = { latlngs: pts, elevs: elevations };
    renderElevation(pts, elevations);
  }catch(err){
    console.warn('Elevation failed:', err);
    hideElevation();
  }
}

// OpenTopoData batching with dataset chain + cubic interpolation
async function fetchElevationsOpenTopo(latlngs){
  const DATASET = 'eudem25m,srtm90m'; // try EU-DEM first, then SRTM
  const BATCH = 100;
  const out = [];
  for (let i=0; i<latlngs.length; i+=BATCH){
    const chunk = latlngs.slice(i,i+BATCH)
      .map(([lat,lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join('|');
    const url = `https://api.opentopodata.org/v1/${DATASET}` +
                `?locations=${encodeURIComponent(chunk)}&interpolation=cubic`;
    const r = await fetch(url);
    const j = await r.json();
    if(!r.ok || !j || !j.results) throw new Error('OpenTopoData error');
    j.results.forEach(res => out.push(res.elevation));
  }
  return out;
}

function renderElevation(latlngs, elevsRaw){
  if(!elevsRaw || !elevsRaw.length) return hideElevation();

  // smooth it
  const level = smoothSel.value;
  const elevs = smoothSeries(elevsRaw, level);

  // Compute stats on smoothed series
  let min = Infinity, max = -Infinity, gain = 0, loss = 0;
  for(let i=0;i<elevs.length;i++){
    const z = elevs[i]; if(z==null) continue;
    if(z<min) min = z; if(z>max) max = z;
    if(i>0 && elevs[i-1]!=null){
      const dz = z - elevs[i-1];
      if(dz>0) gain += dz; else loss += -dz;
    }
  }

  statMin.textContent  = `Min: ${Math.round(min)} m`;
  statMax.textContent  = `Max: ${Math.round(max)} m`;
  statGain.textContent = `Ascent: ${Math.round(gain)} m`;
  statLoss.textContent = `Descent: ${Math.round(loss)} m`;

  // Build SVG
  const W = elevChart.clientWidth || 600;
  const H = elevChart.clientHeight || 160;
  const pad = 24;
  const w = W - pad*2;
  const h = H - pad*2;

  const eMin = Math.min(min, max-1);
  const eMax = max;
  const scaleX = (i)=> pad + (i/(elevs.length-1))*w;
  const scaleY = (z)=> pad + h - ((z - eMin) / (eMax - eMin || 1)) * h;

  // Path
  let d = '';
  for(let i=0;i<elevs.length;i++){
    const x = scaleX(i), y = scaleY(elevs[i]);
    d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
  }
  const area = `${d} L ${pad + w} ${pad + h} L ${pad} ${pad + h} Z`;

  // Axis ticks
  const ticks = [eMin, (eMin+eMax)/2, eMax];

  elevChart.innerHTML = `
    <defs>
      <linearGradient id="grad" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#22c55e" stop-opacity="0.35"/>
        <stop offset="100%" stop-color="#22c55e" stop-opacity="0.05"/>
      </linearGradient>
    </defs>
    <rect x="0" y="0" width="${W}" height="${H}" fill="transparent"/>
    <path d="${area}" fill="url(#grad)"></path>
    <path d="${d}" fill="none" stroke="#22c55e" stroke-width="2"></path>
    ${ticks.map((t,i)=>{
      const y = scaleY(t);
      return `<line x1="${pad}" y1="${y}" x2="${pad+w}" y2="${y}" stroke="#223" stroke-dasharray="3,3"/>
              <text x="${pad-6}" y="${y+4}" text-anchor="end" fill="#9ca3af" font-size="11">${Math.round(t)} m</text>`;
    }).join('')}
  `;

  // Hover tooltip
  const tooltip = document.createElementNS('http://www.w3.org/2000/svg','g');
  const line   = document.createElementNS('http://www.w3.org/2000/svg','line');
  const dot    = document.createElementNS('http://www.w3.org/2000/svg','circle');
  const label  = document.createElementNS('http://www.w3.org/2000/svg','text');
  line.setAttribute('stroke','#93c5fd'); line.setAttribute('y1', pad); line.setAttribute('y2', pad+h);
  dot.setAttribute('r','3'); dot.setAttribute('fill','#93c5fd'); dot.setAttribute('stroke','#111827');
  label.setAttribute('fill','#e5e7eb'); label.setAttribute('font-size','11');
  tooltip.appendChild(line); tooltip.appendChild(dot); tooltip.appendChild(label);
  elevChart.appendChild(tooltip);
  tooltip.style.display = 'none';

  function nearestIndex(mouseX){
    const x = Math.max(pad, Math.min(mouseX, pad+w));
    const ratio = (x - pad)/w;
    return Math.round(ratio * (elevs.length-1));
  }

  elevChart.onmousemove = (evt)=>{
    const rect = elevChart.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const i = nearestIndex(x);
    const xi = scaleX(i), yi = scaleY(elevs[i]);
    tooltip.style.display = '';
    line.setAttribute('x1', xi); line.setAttribute('x2', xi);
    dot.setAttribute('cx', xi);  dot.setAttribute('cy', yi);
    label.setAttribute('x', xi+6); label.setAttribute('y', yi-8);
    const distTotal = turf.length(mergeToLineString(currentGeo), {units:'kilometers'}) || 0;
    const distAt = (distTotal * (i/(elevs.length-1)));
    label.textContent = `${Math.round(elevs[i])} m @ ${distAt.toFixed(2)} km`;
  };
  elevChart.onmouseleave = ()=>{ tooltip.style.display = 'none'; };

  elevWrap.style.display = 'block';
}

/* ============== Profile change triggers re-route ============== */
profileSel.addEventListener('change', ()=>{ if(waypoints.length>=2) computeRoute(); });

/* ============== Exporters ============== */
const btnGpx = document.getElementById('btnGpx');
const btnKml = document.getElementById('btnKml');
const btnGeo = document.getElementById('btnGeo');

btnGeo.addEventListener('click', ()=>{
  if(!currentGeo){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.geojson';
  download(name, JSON.stringify(currentGeo, null, 2), 'application/geo+json');
});

btnGpx.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.gpx';
  const gpx = toGPX(line, current_elev_cache);
  download(name, gpx, 'application/gpx+xml');
});

btnKml.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.kml';
  const kml = toKML(line, current_elev_cache);
  download(name, kml, 'application/vnd.google-earth.kml+xml');
});

function download(filename, data, mime='application/octet-stream'){
  const blob = new Blob([data], {type:mime});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

function toGPX(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  // Try to include elevation if cache length matches samples:
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    // resample elevations to match coords length
    elevs = resampleArray(elevCache.elevs, coords.length);
  }
  const name = escapeXml(routeName.value || 'Route');
  const trkpts = coords.map((c,i)=>{
    const lon = c[0].toFixed(6), lat = c[1].toFixed(6);
    const ele = elevs ? `<ele>${Number(elevs[i]).toFixed(1)}</ele>` : '';
    return `<trkpt lat="${lat}" lon="${lon}">${ele}</trkpt>`;
  }).join('');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Leaflet+BRouter" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><name>${name}</name></metadata>
  <trk><name>${name}</name><trkseg>${trkpts}</trkseg></trk>
</gpx>`;
}

function toKML(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    elevs = resampleArray(elevCache.elevs, coords.length);
  }
  const name = escapeXml(routeName.value || 'Route');
  const coordStr = coords.map((c,i)=>{
    const z = elevs ? Number(elevs[i]).toFixed(1) : '0';
    return `${c[0].toFixed(6)},${c[1].toFixed(6)},${z}`;
  }).join(' ');
  return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Placemark>
      <name>${name}</name>
      <Style><LineStyle><color>ff55c522</color><width>4</width></LineStyle></Style>
      <LineString><tessellate>1</tessellate><coordinates>${coordStr}</coordinates></LineString>
    </Placemark>
  </Document>
</kml>`;
}

function resampleArray(arr, n){
  // simple linear resample from arr.length -> n
  const out = new Array(n);
  const m = arr.length;
  for(let i=0;i<n;i++){
    const t = (i*(m-1))/(n-1);
    const i0 = Math.floor(t), i1 = Math.min(m-1, i0+1);
    const a = arr[i0], b = arr[i1];
    const frac = t - i0;
    out[i] = a + (b - a) * frac;
  }
  return out;
}

function escapeXml(s){ return String(s).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c])); }

</script>
</body>
</html>
