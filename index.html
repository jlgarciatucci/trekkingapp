<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OSM Route Planner — BRouter + Robust Elevation</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@7.1.0/turf.min.js"></script>

<style>
  html,body,#map{height:100%;margin:0}
  #map{position:relative}

  .ui{
    position:absolute;top:10px;left:10px;z-index:9999;
    background:#111827;color:#e5e7eb;padding:10px 12px;border-radius:12px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto; box-shadow:0 6px 20px rgba(0,0,0,.35)
  }
  .ui *{font-size:14px}
  .ui select,.ui button,.ui input{
    background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:10px;
    padding:8px 10px;margin-right:6px; outline:none
  }
  .row{margin-top:8px; font-family: Segoe UI;}
  .ok{color:#86efac}.warn{color:#fde68a}.err{color:#fca5a5}
  .badge{background:#0b1220;border:1px solid #334155;border-radius:999px;padding:6px 10px;margin-left:8px}

  /* Elevation panel (desktop defaults) */
  #elevWrap{
    position:absolute;left:10px;right:10px;bottom:10px;z-index:9998;
    background:#0b1220;color:#e5e7eb;border:1px solid #334155;border-radius:12px;
    padding:10px 12px;box-shadow:0 6px 20px rgba(0,0,0,.35);
    transition:height .18s ease, transform .18s ease, opacity .18s ease;
  }
  #elevHeader{display:flex;gap:10px;align-items:center;flex-wrap:wrap; font-family: Roboto;}
  #elevHeader .stat{background:#111827;border:1px solid #334155;border-radius:10px;padding:4px 8px}
  #elevChart{width:100%;height:160px;display:block;margin-top:8px;background:#091018;border-radius:8px}
  #elevHint{opacity:.75;font-size:12px;margin-left:auto}

  /* Toggle button for elevation (mobile sheet) */
  #toggleElev{
    position:absolute; right:12px; bottom:12px; z-index:9999;
    width:48px; height:48px; border-radius:999px; display:flex; align-items:center; justify-content:center;
    background:#111827; color:#e5e7eb; border:1px solid #334155;
    box-shadow:0 6px 20px rgba(0,0,0,.35); cursor:pointer; user-select:none;
    display:none; /* desktop hidden; shown on mobile */
  }

  /* Bottom-left Basemap control */
  #basemapCtrl{
    position:absolute;
    left:12px;
    bottom:12px;
    z-index:9999;
    background:#111827;
    border:1px solid #334155;
    border-radius:8px;
    padding:4px 6px;
    box-shadow:0 4px 12px rgba(0,0,0,.35);
  }
  #basemapCtrl select{
    background:#0b1220;
    color:#e5e7eb;
    border:none;
    font-size:14px;
    padding:4px 6px;
    outline:none;
  }

  /* Bottom-left Waymarked overlay toggle (mobile-friendly) */
  #overlayCtrl{
    position:absolute; left:12px; bottom:64px; z-index:9999;
    background:#111827; border:1px solid #334155; border-radius:8px;
    padding:6px 10px; box-shadow:0 4px 12px rgba(0,0,0,.35); color:#e5e7eb;
    font-family:system-ui,-apple-system,Segoe UI,Roboto; font-size:14px;
  }
  #overlayCtrl input{ vertical-align:middle; margin-right:6px }

  /* Layers control (dark UI) */
  .leaflet-control-layers{
    border-radius:12px; overflow:hidden;
    background:#111827; color:#e5e7eb; border:1px solid #334155;
  }
  .leaflet-control-layers-expanded{ background:#111827; color:#e5e7eb; }
  .leaflet-control-layers-list label{ color:#e5e7eb; }

  /* ---------- Mobile layout tweaks ---------- */
  @media (max-width: 768px){
    .ui{
      left:8px; right:8px; top:8px;
      padding:8px 10px; max-width:unset
    }
    .ui select,.ui button,.ui input{
      padding:6px 8px; margin-right:4px; font-size:13px;
    }
    .badge{padding:4px 8px}

    /* Turn elevation into a bottom sheet */
    #elevWrap{
      left:0; right:0; bottom:0; border-radius:12px 12px 0 0;
      padding:10px 12px 12px 12px;
      max-height:60vh;   /* never cover too much */
      overflow:hidden;
      opacity:0; transform:translateY(8px); pointer-events:none; /* collapsed by default */
    }
    #elevWrap.open{
      opacity:1; transform:translateY(0); pointer-events:auto;
    }
    /* Shorter chart on mobile */
    #elevChart{ height:140px; }

    /* Show the toggle FAB on mobile */
    #toggleElev{ display:flex; }

    /* Hide Leaflet’s built-in layers control on mobile (we use bottom-left selector) */
    .leaflet-control-layers { display:none !important; }

    /* Lift the overlay toggle a bit above the FAB/basemap */
    #overlayCtrl{ bottom:68px; left:12px; right:auto }
  }
</style>
</head>
<body>
<div id="map"></div>

<div class="ui">
  <div class="row">
    <b>Routing:</b>
    <select id="profile">
      <option value="hiking">hiking (prefers trails)</option>
      <option value="foot">foot (pedestrian)</option>
      <option value="trekking">trekking (bike/hike mix)</option>
    </select>
    <span id="dist" class="badge">0.00 km</span>
  </div>
  <div class="row">
    <input id="routeName" placeholder="Route name" size="16" />
    <button id="btnGpx">Export GPX</button>
    <button id="btnKml">KML</button>
    <button id="btnGeo">GeoJSON</button>
    <button id="btnClear">Clear</button>
    <!-- Load GPX -->
    <button id="btnLoadGpx">Load GPX</button>
    <input type="file" id="gpxFile" accept=".gpx" style="display:none" />
    <span id="status" class="ok">Click to add</span>
  </div>
</div>

<!-- mobile toggle for elevation -->
<div id="toggleElev" title="Show/hide elevation">⌄</div>

<!-- Bottom-left basemap selector (always visible) -->
<div id="basemapCtrl" title="Change basemap">
  <select id="basemapSel">
    <option value="osm">OSM</option>
    <option value="sat">Satellite</option>
    <option value="topo">Topo</option>
    <option value="dark">Dark</option>
  </select>
</div>

<!-- Bottom-left Waymarked Trails overlay toggle -->
<div id="overlayCtrl" title="Waymarked Trails overlay">
  <label><input type="checkbox" id="wmToggle"> Waymarked Trails (Hiking)</label>
</div>

<!-- Elevation panel -->
<div id="elevWrap" style="display:none">
  <div id="elevHeader">
    <strong>Elevation profile</strong>
    <span class="stat" id="statMin">Min: —</span>
    <span class="stat" id="statMax">Max: —</span>
    <span class="stat" id="statGain">Ascent: —</span>
    <span class="stat" id="statLoss">Descent: —</span>
    <span id="elevHint">smoothing: medium</span>
  </div>
  <svg id="elevChart"></svg>
</div>

<script>
/* ============== Map ============== */
const map = L.map('map').setView([41.387, 2.170], 12);

// --- Base maps ---
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 20, attribution: '© OpenStreetMap contributors'
});
const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20, attribution: 'Tiles © Esri — Sources: Esri, USGS, IGN, etc.'
});
const esriLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20, attribution: 'Labels © Esri'
});
const openTopo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
  maxZoom: 17, attribution: '© OpenStreetMap, SRTM — OpenTopoMap (CC-BY-SA)'
});
const cartoDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  maxZoom: 20, attribution: '© OpenStreetMap, © CARTO'
});
osm.addTo(map);

// ---- Waymarked Trails overlay (Hiking) ----
const waymarkedHiking = L.tileLayer(
  'https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png',
  {
    maxZoom: 20,
    opacity: 0.9,
    attribution: '© waymarkedtrails.org, © OpenStreetMap contributors'
  }
);

// Leaflet layers control (desktop)
const baseLayers = {
  "OSM Standard": osm,
  "Esri Satellite": esriSat,
  "OpenTopoMap": openTopo,
  "CARTO Dark": cartoDark
};
const overlays = {
  "Labels (Esri)": esriLabels,
  "Waymarked Trails (Hiking)": waymarkedHiking
};
L.control.layers(baseLayers, overlays, { position: 'topright', collapsed: true }).addTo(map);

// Auto-show labels with satellite when using Leaflet control
map.on('baselayerchange', (e) => {
  if (e.name === 'Esri Satellite' && !map.hasLayer(esriLabels)) esriLabels.addTo(map);
  if (e.name !== 'Esri Satellite' && map.hasLayer(esriLabels)) esriLabels.remove();
});

// ---- Basemap selector (bottom-left) ----
const basemapSel = document.getElementById('basemapSel');
let currentBase = osm; // the one initially added

function setBasemap(key){
  if (currentBase) map.removeLayer(currentBase);

  if (key === 'osm') {
    currentBase = osm;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  } else if (key === 'sat') {
    currentBase = esriSat;
    if (!map.hasLayer(esriLabels)) esriLabels.addTo(map);
  } else if (key === 'topo') {
    currentBase = openTopo;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  } else if (key === 'dark') {
    currentBase = cartoDark;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  } else {
    currentBase = osm;
    if (map.hasLayer(esriLabels)) map.removeLayer(esriLabels);
  }
  currentBase.addTo(map);
}

if (basemapSel){
  basemapSel.value = 'osm';
  basemapSel.addEventListener('change', (e)=> setBasemap(e.target.value));
}

// Keep the select in sync if user changes via desktop control
map.on('baselayerchange', (e) => {
  const name = e.name || '';
  if (!basemapSel) return;
  if (name.includes('OSM')) basemapSel.value = 'osm';
  else if (name.includes('Satellite')) basemapSel.value = 'sat';
  else if (name.includes('Topo')) basemapSel.value = 'topo';
  else if (name.includes('Dark')) basemapSel.value = 'dark';
});

// ---- Mobile-friendly Waymarked overlay toggle ----
const wmToggle = document.getElementById('wmToggle');
wmToggle.addEventListener('change', (e) => {
  if (e.target.checked) {
    waymarkedHiking.addTo(map);
  } else {
    map.removeLayer(waymarkedHiking);
  }
});
// keep checkbox state in sync with desktop control
map.on('overlayadd',   e => { if (e.layer === waymarkedHiking) wmToggle.checked = true;  });
map.on('overlayremove',e => { if (e.layer === waymarkedHiking) wmToggle.checked = false; });

// default off
wmToggle.checked = map.hasLayer(waymarkedHiking);

/* ============== UI refs ============== */
const profileSel = document.getElementById('profile');
const distBadge  = document.getElementById('dist');
const statusEl   = document.getElementById('status');
const routeName  = document.getElementById('routeName');
const toggleElev = document.getElementById('toggleElev');
const elevWrap   = document.getElementById('elevWrap');
const elevChart  = document.getElementById('elevChart');

function status(msg, cls='ok'){ statusEl.className = cls; statusEl.textContent = msg; }

/* ============== Waypoints & markers ============== */
let waypoints = [];        // array of L.LatLng
let markersLayer = L.layerGroup().addTo(map);
let routeLayer   = null;   // L.GeoJSON of the route
let currentGeo   = null;   // GeoJSON FeatureCollection of the route
let activeRouteRequest = 0;
let activeElevationRequest = 0;
const profileCursorMarker = L.circleMarker([0,0], {
  radius: 7,
  color: '#38bdf8',
  weight: 2,
  fillColor: '#0ea5e9',
  fillOpacity: 0.9,
  opacity: 1
});

map.on('click', (e)=> addWaypoint(e.latlng));

function addWaypoint(latlng){
  waypoints.push(latlng);
  redrawMarkers();
  if(waypoints.length >= 2) computeRoute();
}

function redrawMarkers(){
  markersLayer.clearLayers();
  waypoints.forEach((ll, idx)=>{
    const label = (idx===0?'Start': (idx===waypoints.length-1?'End':'WP' + idx));
    const m = L.marker(ll, { draggable:true, title:label }).addTo(markersLayer);
    m.bindTooltip(label, {permanent:true, direction:'top', offset:[0,-12]});
    m.on('dragend', (ev)=>{ waypoints[idx] = ev.target.getLatLng(); computeRoute(); });
    m.on('contextmenu', ()=>{ // right-click to remove a waypoint (long-press on mobile)
      waypoints.splice(idx,1);
      redrawMarkers();
      if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; currentGeo = null; }
      hideElevation();
      if(waypoints.length >= 2) computeRoute(); else updateDistance(0);
    });
  });
}

document.getElementById('btnClear').onclick = ()=>{
  waypoints = [];
  redrawMarkers();
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation();
  updateDistance(0);
  status('cleared','ok');
};

/* ============== Routing (BRouter first, OSRM foot fallback) ============== */
async function computeRoute(){
  const requestId = ++activeRouteRequest;
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation();
  status('routing with BRouter…','warn');

  try{
    const geo = await fetchBRouterGeoJSON(waypoints, profileSel.value);
    if (requestId !== activeRouteRequest) return;
    drawRouteGeoJSON(geo);
    status('ok (BRouter)','ok');
    await buildElevation(geo, requestId);
  }catch(err){
    if (requestId !== activeRouteRequest) return;
    console.warn('BRouter failed:', err);
    status('BRouter failed → trying OSRM foot…','warn');
    try{
      const geo = await fetchOSRMFootGeoJSON(waypoints);
      if (requestId !== activeRouteRequest) return;
      drawRouteGeoJSON(geo);
      status('ok (OSRM foot fallback)','ok');
      await buildElevation(geo, requestId);
    }catch(e2){
      if (requestId !== activeRouteRequest) return;
      console.error('OSRM fallback failed:', e2);
      status('routing failed on all services','err');
    }
  }
}

function encodeLonLats(pts){
  // BRouter expects lon,lat pairs bar-separated
  return pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join('|');
}

async function fetchBRouterGeoJSON(pts, profile){
  const lonlats = encodeLonLats(pts);
  const url = `https://brouter.de/brouter?lonlats=${encodeURIComponent(lonlats)}&profile=${encodeURIComponent(profile)}&alternativeidx=0&format=geojson`;
  const r = await fetchWithTimeout(url, { method:'GET' }, 15000);
  if(!r.ok) throw new Error('HTTP '+r.status);
  return await r.json(); // FeatureCollection
}

async function fetchOSRMFootGeoJSON(pts){
  const coords = pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join(';');
  const url = `https://routing.openstreetmap.de/routed-foot/route/v1/foot/${coords}?overview=full&geometries=geojson&steps=false&alternatives=false`;
  const r = await fetchWithTimeout(url, { method:'GET' }, 15000);
  const j = await r.json().catch(()=>null);
  if(!r.ok || !j || !j.routes || !j.routes.length) throw new Error('OSRM foot error');
  const line = j.routes[0].geometry; // GeoJSON LineString
  return { type:'FeatureCollection', features:[{ type:'Feature', properties:{source:'osrm-foot'}, geometry: line }] };
}

async function fetchWithTimeout(url, options = {}, timeoutMs = 12000){
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(new Error('timeout')), timeoutMs);
  try {
    return await fetch(url, { ...options, signal: controller.signal });
  } finally {
    clearTimeout(timer);
  }
}

/* ============== Draw + distance + fit ============== */
function drawRouteGeoJSON(geo){
  currentGeo = geo;
  if(routeLayer){ map.removeLayer(routeLayer); }
  routeLayer = L.geoJSON(geo, { style: { color:'#22c55e', weight:5, opacity:0.95 } }).addTo(map);
  try { map.fitBounds(routeLayer.getBounds(), { padding:[20,20] }); } catch(_) {}
  const merged = mergeToLineString(geo);
  const km = merged ? turf.length(merged, {units:'kilometers'}) : 0;
  updateDistance(km);
}

function mergeToLineString(fc){
  if(!fc || !fc.features) return null;
  const coords = [];
  fc.features.forEach(f=>{
    if(!f.geometry) return;
    if(f.geometry.type==='LineString') coords.push(...f.geometry.coordinates);
    if(f.geometry.type==='MultiLineString') f.geometry.coordinates.forEach(c=>coords.push(...c));
  });
  return coords.length ? { type:'Feature', geometry:{ type:'LineString', coordinates: coords }, properties:{} } : null;
}

function updateDistance(km){
  distBadge.textContent = `${(km||0).toFixed(2)} km`;
}

function getWaypointProfileAnchors(line, sampleCount){
  if (!line || !Array.isArray(waypoints) || waypoints.length < 2 || sampleCount < 2) return [];

  const totalKm = turf.length(line, {units:'kilometers'}) || 0;
  if (totalKm <= 0) return [];

  return waypoints.map((ll, idx) => {
    const pt = turf.point([ll.lng, ll.lat]);
    const snapped = turf.nearestPointOnLine(line, pt, {units:'kilometers'});
    const locationKm = Math.max(0, Math.min(totalKm, snapped.properties?.location ?? 0));
    const profileIndex = Math.round((locationKm / totalKm) * (sampleCount - 1));

    return {
      index: profileIndex,
      label: idx === 0 ? 'S' : (idx === waypoints.length - 1 ? 'E' : `W${idx}`)
    };
  });
}

/* ============== Elevation profile (robust) ============== */
const statMin    = document.getElementById('statMin');
const statMax    = document.getElementById('statMax');
const statGain   = document.getElementById('statGain');
const statLoss   = document.getElementById('statLoss');

function hideElevation(){
  elevWrap.style.display = 'none';
  elevWrap.classList.remove('open');
  elevChart.innerHTML = '';
  toggleElev.textContent = '⌃';
  if (map.hasLayer(profileCursorMarker)) map.removeLayer(profileCursorMarker);
}

// simple median filter (odd window)
function medianFilter(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null).sort((x,y)=>x-y);
    out[i] = slice.length ? slice[Math.floor(slice.length/2)] : arr[i];
  }
  return out;
}
// centered moving average (odd window)
function movingAverage(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null);
    const sum = slice.reduce((s,v)=>s+v,0);
    out[i] = slice.length ? (sum/slice.length) : arr[i];
  }
  return out;
}
function smoothSeries(raw, level){
  if(level==='none') return raw.slice();
  const cfg = {
    low:  { med:5, avg:7  },
    med:  { med:5, avg:11 },
    high: { med:7, avg:15 }
  }[level] || { med:5, avg:7 };
  const m = medianFilter(raw, cfg.med);
  return movingAverage(m, cfg.avg);
}

let current_elev_cache = null;

// Helper: detect if route roughly lies in Europe to pick EU-DEM
function routeInEurope(lineFeature){
  // rough Europe bbox [W,S,E,N]
  const EUROPE_BBOX = [-31.5, 27.5, 45.5, 71.5];
  try {
    const bb = turf.bbox(lineFeature); // [minX, minY, maxX, maxY]
    const cx = (bb[0] + bb[2]) / 2, cy = (bb[1] + bb[3]) / 2;
    return (cx >= EUROPE_BBOX[0] && cx <= EUROPE_BBOX[2] &&
            cy >= EUROPE_BBOX[1] && cy <= EUROPE_BBOX[3]);
  } catch { return false; }
}

async function buildElevation(geo, routeRequestId = activeRouteRequest){
  const elevationRequestId = ++activeElevationRequest;
  try{
    const line = mergeToLineString(geo);
    if(!line) { hideElevation(); return; }

    const lengthKm = turf.length(line, {units:'kilometers'});

    // modest sampling: ~20 pts/km (cap 250) → fewer rate limits and shorter URLs
    const samples = Math.max(30, Math.min(250, Math.round(lengthKm * 20)));

    const pts = [];
    for (let i=0;i<=samples;i++){
      const seg = turf.along(line, (lengthKm * i / samples), {units:'kilometers'});
      const [x,y] = seg.geometry.coordinates;
      pts.push([y,x]); // lat,lon
    }

    // Choose dataset: EU → eudem25m, otherwise srtm30m
    const dataset = routeInEurope(line) ? 'eudem25m' : 'srtm30m';

    const elevations = await fetchElevationsRobust(pts, dataset);
    if (routeRequestId !== activeRouteRequest || elevationRequestId !== activeElevationRequest) return;

    if (!elevations || elevations.every(v => v == null)){
      status('Elevation unavailable (all providers failed)', 'warn');
      hideElevation();
      return;
    }

    current_elev_cache = { latlngs: pts, elevs: elevations };

    // Show panel before rendering so SVG can measure full responsive width.
    elevWrap.style.display = 'block';
    renderElevation(pts, elevations);
    if (window.matchMedia('(max-width: 768px)').matches){
      elevWrap.classList.add('open');
      toggleElev.textContent = '⌄';
    }
  }catch(err){
    console.warn('Elevation failed:', err);
    status('Elevation error (see console)', 'warn');
    hideElevation();
  }
}

// Robust fetch: OpenTopoData first (batched, cubic), fallback to Open-Elevation (batched).
async function fetchElevationsRobust(latlngs, dataset='srtm30m'){
  try {
    const vals = await fetchOpenTopoData(latlngs, dataset);
    if (vals && vals.some(v => v != null)) return vals;
  } catch (e) {
    console.warn('OpenTopoData error:', e);
  }
  try {
    const vals2 = await fetchOpenElevation(latlngs);
    return vals2;
  } catch (e2) {
    console.warn('Open-Elevation error:', e2);
  }
  return new Array(latlngs.length).fill(null);
}

async function fetchOpenTopoData(latlngs, dataset){
  const BATCH = 80; // keep URLs short/reliable
  const out = [];
  for (let i=0; i<latlngs.length; i+=BATCH){
    const chunk = latlngs.slice(i, i+BATCH)
      .map(([lat,lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join('|');
    const url = `https://api.opentopodata.org/v1/${dataset}` +
                `?locations=${encodeURIComponent(chunk)}&interpolation=cubic`;
    const r = await fetchWithTimeout(url, {}, 15000);
    const j = await r.json().catch(()=>null);
    if (!r.ok || !j || !j.results) throw new Error(`OpenTopoData ${r.status}`);
    j.results.forEach(res => out.push(res ? res.elevation : null));
  }
  return out;
}

async function fetchOpenElevation(latlngs){
  const BATCH = 100;
  const out = [];
  for (let i=0; i<latlngs.length; i+=BATCH){
    const chunk = latlngs.slice(i, i+BATCH)
      .map(([lat,lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join('|');
    const url = `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(chunk)}`;
    const r = await fetchWithTimeout(url, {}, 15000);
    const j = await r.json().catch(()=>null);
    if (!r.ok || !j || !j.results) throw new Error(`Open-Elevation ${r.status}`);
    j.results.forEach(res => out.push(res ? res.elevation : null));
  }
  return out;
}

function renderElevation(latlngs, elevsRaw){
  if(!elevsRaw || !elevsRaw.length) return hideElevation();

  // always use MEDIUM smoothing
  const elevs = smoothSeries(elevsRaw, 'med');
  if (!elevs.some(v => v != null && Number.isFinite(v))) return hideElevation();

  // Compute stats on smoothed series
  let min = Infinity, max = -Infinity, gain = 0, loss = 0;
  for(let i=0;i<elevs.length;i++){
    const z = elevs[i]; if(z==null) continue;
    if(z<min) min = z; if(z>max) max = z;
    if(i>0 && elevs[i-1]!=null){
      const dz = z - elevs[i-1];
      if(dz>0) gain += dz; else loss += -dz;
    }
  }

  statMin.textContent  = `Min: ${Math.round(min)} m`;
  statMax.textContent  = `Max: ${Math.round(max)} m`;
  statGain.textContent = `Ascent: ${Math.round(gain)} m`;
  statLoss.textContent = `Descent: ${Math.round(loss)} m`;

  // Build SVG
  const W = elevChart.clientWidth || 600;
  const H = elevChart.clientHeight || 160;
  const pad = 24;
  const w = W - pad*2;
  const h = H - pad*2;

  const eMin = Math.min(min, max-1);
  const eMax = max;
  const scaleX = (i)=> pad + (i/(elevs.length-1))*w;
  const scaleY = (z)=> pad + h - ((z - eMin) / (eMax - eMin || 1)) * h;

  const routeLine = mergeToLineString(currentGeo);
  const waypointAnchors = getWaypointProfileAnchors(routeLine, elevs.length);

  // Path
  let d = '';
  for(let i=0;i<elevs.length;i++){
    const x = scaleX(i), y = scaleY(elevs[i]);
    d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
  }
  const area = `${d} L ${pad + w} ${pad + h} L ${pad} ${pad + h} Z`;

  // Axis ticks
  const ticks = [eMin, (eMin+eMax)/2, eMax];

  elevChart.innerHTML = `
    <defs>
      <linearGradient id="grad" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#22c55e" stop-opacity="0.35"/>
        <stop offset="100%" stop-color="#22c55e" stop-opacity="0.05"/>
      </linearGradient>
    </defs>
    <rect x="0" y="0" width="${W}" height="${H}" fill="transparent"/>
    <path d="${area}" fill="url(#grad)"></path>
    <path d="${d}" fill="none" stroke="#22c55e" stroke-width="2"></path>
    ${ticks.map((t,i)=>{
      const y = scaleY(t);
      return `<line x1="${pad}" y1="${y}" x2="${pad+w}" y2="${y}" stroke="#223" stroke-dasharray="3,3"/>
              <text x="${pad-6}" y="${y+4}" text-anchor="end" fill="#9ca3af" font-size="11">${Math.round(t)} m</text>`;
    }).join('')}
    ${waypointAnchors.map((wp)=>{
      const x = scaleX(wp.index);
      return `<line x1="${x}" y1="${pad}" x2="${x}" y2="${pad+h}" stroke="#60a5fa" stroke-dasharray="2,3" opacity="0.9"/>
              <text x="${x}" y="${pad-6}" text-anchor="middle" fill="#93c5fd" font-size="10">${wp.label}</text>`;
    }).join('')}
  `;

  // Hover/Touch tooltip
  const tooltip = document.createElementNS('http://www.w3.org/2000/svg','g');
  const guideLine = document.createElementNS('http://www.w3.org/2000/svg','line');
  const dot    = document.createElementNS('http://www.w3.org/2000/svg','circle');
  const label  = document.createElementNS('http://www.w3.org/2000/svg','text');
  guideLine.setAttribute('stroke','#93c5fd'); guideLine.setAttribute('y1', pad); guideLine.setAttribute('y2', pad+h);
  dot.setAttribute('r','3'); dot.setAttribute('fill','#93c5fd'); dot.setAttribute('stroke','#111827');
  label.setAttribute('fill','#e5e7eb'); label.setAttribute('font-size','11');
  tooltip.appendChild(guideLine); tooltip.appendChild(dot); tooltip.appendChild(label);
  elevChart.appendChild(tooltip);
  tooltip.style.display = 'none';

  function nearestIndex(mouseX){
    const x = Math.max(pad, Math.min(mouseX, pad+w));
    const ratio = (x - pad)/w;
    return Math.round(ratio * (elevs.length-1));
  }

  function updateTip(evt){
    const rect = elevChart.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const x = clientX - rect.left;
    const i = nearestIndex(x);
    const xi = scaleX(i), yi = scaleY(elevs[i]);
    tooltip.style.display = '';
    guideLine.setAttribute('x1', xi); guideLine.setAttribute('x2', xi);
    dot.setAttribute('cx', xi);  dot.setAttribute('cy', yi);
    label.setAttribute('x', xi+6); label.setAttribute('y', yi-8);
    const distTotal = routeLine ? (turf.length(routeLine, {units:'kilometers'}) || 0) : 0;
    const distAt = (distTotal * (i/(elevs.length-1)));
    label.textContent = `${Math.round(elevs[i])} m @ ${distAt.toFixed(2)} km`;

    if (routeLine && distTotal > 0){
      const snapPt = turf.along(routeLine, distAt, { units:'kilometers' });
      const [lon, lat] = snapPt.geometry.coordinates;
      const markerLatLng = L.latLng(lat, lon);
      profileCursorMarker.setLatLng(markerLatLng);
      if (!map.hasLayer(profileCursorMarker)) profileCursorMarker.addTo(map);

      // Keep moving marker visible while scrubbing profile.
      if (!map.getBounds().pad(-0.1).contains(markerLatLng)){
        map.panTo(markerLatLng, { animate:true, duration:0.2 });
      }
      profileCursorMarker.setLatLng([lat, lon]);
      if (!map.hasLayer(profileCursorMarker)) profileCursorMarker.addTo(map);
    }
  }

  elevChart.onmousemove = updateTip;
  elevChart.ontouchstart = updateTip;
  elevChart.ontouchmove = updateTip;
  function hideTip(){
    tooltip.style.display = 'none';
    if (map.hasLayer(profileCursorMarker)) map.removeLayer(profileCursorMarker);
  }

  elevChart.onmouseleave = hideTip;
  elevChart.ontouchend = hideTip;
}

/* ============== Profile change triggers re-route ============== */
profileSel.addEventListener('change', ()=>{ if(waypoints.length>=2) computeRoute(); });

/* ============== Exporters ============== */
const btnGpx = document.getElementById('btnGpx');
const btnKml = document.getElementById('btnKml');
const btnGeo = document.getElementById('btnGeo');

btnGeo.addEventListener('click', ()=>{
  if(!currentGeo){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.geojson';
  download(name, JSON.stringify(currentGeo, null, 2), 'application/geo+json');
});

btnGpx.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.gpx';
  const gpx = toGPX(line, current_elev_cache);
  download(name, gpx, 'application/gpx+xml');
});

btnKml.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.kml';
  const kml = toKML(line, current_elev_cache);
  download(name, kml, 'application/vnd.google-earth.kml+xml');
});

function download(filename, data, mime='application/octet-stream'){
  const blob = new Blob([data], {type:mime});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

function toGPX(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    elevs = resampleArray(elevCache.elevs, coords.length); // resample to match
  }
  const name = escapeXml(routeName.value || 'Route');
  const trkpts = coords.map((c,i)=>{
    const lon = c[0].toFixed(6), lat = c[1].toFixed(6);
    const ele = elevs ? `<ele>${Number(elevs[i]).toFixed(1)}</ele>` : '';
    return `<trkpt lat="${lat}" lon="${lon}">${ele}</trkpt>`;
  }).join('');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Leaflet+BRouter" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><name>${name}</name></metadata>
  <trk><name>${name}</name><trkseg>${trkpts}</trkseg></trk>
</gpx>`;
}

function toKML(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    elevs = resampleArray(elevCache.elevs, coords.length);
  }
  const name = escapeXml(routeName.value || 'Route');
  const coordStr = coords.map((c,i)=>{
    const z = elevs ? Number(elevs[i]).toFixed(1) : '0';
    return `${c[0].toFixed(6)},${c[1].toFixed(6)},${z}`;
  }).join(' ');
  return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Placemark>
      <name>${name}</name>
      <Style><LineStyle><color>ff55c522</color><width>4</width></LineStyle></Style>
      <LineString><tessellate>1</tessellate><coordinates>${coordStr}</coordinates></LineString>
    </Placemark>
  </Document>
</kml>`;
}

function resampleArray(arr, n){
  // simple linear resample from arr.length -> n
  const out = new Array(n);
  const m = arr.length;
  for(let i=0;i<n;i++){
    const t = (i*(m-1))/(n-1);
    const i0 = Math.floor(t), i1 = Math.min(m-1, i0+1);
    const a = arr[i0], b = arr[i1];
    const frac = t - i0;
    out[i] = a + (b - a) * frac;
  }
  return out;
}

function escapeXml(s){ return String(s).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c])); }

/* ============== Mobile: elevation toggle ============== */
toggleElev.addEventListener('click', ()=>{
  if (elevWrap.style.display === 'none') return; // nothing to show
  elevWrap.classList.toggle('open');
  toggleElev.textContent = elevWrap.classList.contains('open') ? '⌄' : '⌃';
  // reflow chart after transition
  setTimeout(()=>{ if(current_elev_cache) renderElevation(current_elev_cache.latlngs, current_elev_cache.elevs); }, 220);
});

// Keep profile chart responsive on viewport/layout changes.
window.addEventListener('resize', ()=>{
  if (!current_elev_cache || elevWrap.style.display === 'none') return;
  renderElevation(current_elev_cache.latlngs, current_elev_cache.elevs);
});

/* ============== GPX Loader (no external libs) ============== */
const btnLoadGpx = document.getElementById('btnLoadGpx');
const gpxFileInp = document.getElementById('gpxFile');

btnLoadGpx.addEventListener('click', ()=> gpxFileInp.click());

gpxFileInp.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  try{
    status('Loading GPX…','warn');
    const text = await file.text();
    const geo = parseGPXtoGeoJSON(text);

    if(!geo || !geo.features || !geo.features.length){
      status('No LineString found in GPX','err');
      return;
    }

    // draw and compute elevation (prefer GPX <ele> if present)
    drawRouteGeoJSON(geo);

    // If GPX included elevations, use those directly for the chart.
    const elevFromGpx = extractElevProfileFromGeo(geo);
    if(elevFromGpx && elevFromGpx.latlngs && elevFromGpx.elevs && elevFromGpx.elevs.some(v=>v!=null)){
      current_elev_cache = elevFromGpx;
      elevWrap.style.display = 'block';
      renderElevation(elevFromGpx.latlngs, elevFromGpx.elevs);
      if (window.matchMedia('(max-width: 768px)').matches){
        elevWrap.classList.add('open');
        toggleElev.textContent = '⌄';
      }
      status('GPX loaded (with elevation)','ok');
    }else{
      await buildElevation(geo); // fall back to providers
      status('GPX loaded','ok');
    }

    // Sync route name with file name (optional)
    const baseName = file.name.replace(/\.[^.]+$/,'');
    if(!routeName.value) routeName.value = baseName;

    // Clear waypoints (so routing clicks don’t mix with a loaded track)
    waypoints = [];
    redrawMarkers();
  }catch(err){
    console.error(err);
    status('Failed to load GPX','err');
  }finally{
    gpxFileInp.value = ''; // reset so selecting the same file again retriggers
  }
});

/* ---- GPX parsing helpers ---- */
function parseGPXtoGeoJSON(xmlText){
  const parser = new DOMParser();
  const xml = parser.parseFromString(xmlText, 'application/xml');
  // Tracks
  const trksegs = Array.from(xml.getElementsByTagName('trkseg'));
  const features = [];
  trksegs.forEach(seg=>{
    const pts = Array.from(seg.getElementsByTagName('trkpt')).map(pt=>{
      const lat = parseFloat(pt.getAttribute('lat'));
      const lon = parseFloat(pt.getAttribute('lon'));
      const eleEl = pt.getElementsByTagName('ele')[0];
      const ele = eleEl ? parseFloat(eleEl.textContent) : null;
      return {lat, lon, ele};
    }).filter(p=>isFinite(p.lat) && isFinite(p.lon));
    if(pts.length>=2){
      features.push({
        type:'Feature',
        properties:{ source:'gpx', hasElevation: pts.some(p=>p.ele!=null) },
        geometry:{ type:'LineString', coordinates: pts.map(p=>[p.lon, p.lat, p.ele!=null?p.ele:undefined]) }
      });
    }
  });

  // Routes (fallback if no tracks)
  if(features.length===0){
    const rtepts = Array.from(xml.getElementsByTagName('rtept')).map(pt=>{
      const lat = parseFloat(pt.getAttribute('lat'));
      const lon = parseFloat(pt.getAttribute('lon'));
      const eleEl = pt.getElementsByTagName('ele')[0];
      const ele = eleEl ? parseFloat(eleEl.textContent) : null;
      return {lat, lon, ele};
    }).filter(p=>isFinite(p.lat) && isFinite(p.lon));
    if(rtepts.length>=2){
      features.push({
        type:'Feature',
        properties:{ source:'gpx-route', hasElevation: rtepts.some(p=>p.ele!=null) },
        geometry:{ type:'LineString', coordinates: rtepts.map(p=>[p.lon, p.lat, p.ele!=null?p.ele:undefined]) }
      });
    }
  }

  if(features.length===0) return null;

  return { type:'FeatureCollection', features };
}

function extractElevProfileFromGeo(fc){
  // Merge to LineString (lon,lat,ele?)
  const line = mergeToLineString(fc);
  if(!line) return null;

  const coords = line.geometry.coordinates; // [lon,lat,(ele?)]
  const latlngs = coords.map(c=>[c[1], c[0]]);
  let elevs = coords.map(c => (c.length>=3 && isFinite(c[2])) ? Number(c[2]) : null);

  // If less than 20% of points have elevation, treat as missing
  const present = elevs.filter(v=>v!=null).length;
  if(present/Math.max(1,elevs.length) < 0.2){
    elevs = elevs.map(_=>null);
  }

  return { latlngs, elevs };
}
</script>
</body>
</html>
