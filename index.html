<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>OSM Route Planner — BRouter + Robust Elevation (Mobile)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@7.1.0/turf.min.js"></script>

<style>
  :root{
    --panel-bg:#0b1220;
    --panel-border:#334155;
    --panel-text:#e5e7eb;
    --accent:#22c55e;
  }
  html,body,#map{height:100%;margin:0}
  #map{position:relative}

  .ui{
    position:absolute;top:10px;left:10px;z-index:9999;
    background:#111827;color:var(--panel-text);padding:10px 12px;border-radius:12px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto; box-shadow:0 6px 20px rgba(0,0,0,.35);
    max-width: min(92vw, 560px);
  }
  .ui *{font-size:14px}
  .ui select,.ui button,.ui input{
    background:#0b1220;color:var(--panel-text);border:1px solid var(--panel-border);border-radius:10px;
    padding:8px 10px;margin-right:6px; outline:none
  }
  .row{margin-top:8px; display:flex; flex-wrap:wrap; gap:6px; align-items:center}
  .ok{color:#86efac}.warn{color:#fde68a}.err{color:#fca5a5}
  .badge{background:#0b1220;border:1px solid var(--panel-border);border-radius:999px;padding:6px 10px;margin-left:8px}

  /* Elevation bottom sheet */
  #elevWrap{
    position:absolute;left:0;right:0;bottom:0;z-index:9998;
    background:var(--panel-bg);color:var(--panel-text);border-top:1px solid var(--panel-border);
    box-shadow:0 -8px 24px rgba(0,0,0,.35);
    transition: height .18s ease, transform .18s ease, opacity .18s ease;
    display:none; /* only shown when we have data */
  }
  #elevInner{
    display:flex; flex-direction:column; height:100%;
  }
  #dragHandle{
    width:56px;height:6px;border-radius:999px; background:#303a52;
    margin:8px auto 6px auto;
    touch-action:none;
  }
  #elevHeader{
    display:flex;gap:10px;align-items:center;flex-wrap:wrap;
    padding:0 12px 6px 12px;
  }
  #elevHeader .stat{background:#111827;border:1px solid var(--panel-border);border-radius:10px;padding:4px 8px}
  #elevChart{
    width:100%;flex:1;display:block;margin-top:6px;background:#091018;border-radius:8px;
  }
  #elevHint{opacity:.75;font-size:12px;margin-left:auto}

  /* Toggle FAB for the sheet */
  #toggleElev{
    position:absolute; right:12px; bottom:12px; z-index:9999;
    width:48px; height:48px; border-radius:999px; display:flex; align-items:center; justify-content:center;
    background:#111827; color:var(--panel-text); border:1px solid var(--panel-border);
    box-shadow:0 6px 20px rgba(0,0,0,.35); cursor:pointer; user-select:none;
  }

  /* Leaflet layers control (dark UI) */
  .leaflet-control-layers{
    border-radius:12px; overflow:hidden;
    background:#111827; color:var(--panel-text); border:1px solid var(--panel-border);
  }
  .leaflet-control-layers-expanded{
    background:#111827; color:var(--panel-text);
  }
  .leaflet-control-layers-list label{ color:var(--panel-text); }

  /* Mobile optimizations */
  @media (max-width: 768px){
    .ui{
      left:8px; right:8px; top:8px;
      padding:8px 10px;
    }
    .ui select,.ui button,.ui input{
      padding:6px 8px; margin-right:4px; font-size:13px;
    }
    .badge{padding:4px 8px}
    /* Sheet default sizes on mobile */
    #elevWrap.sheet{ display:block; }
    #elevWrap.sheet.closed{ height: 0; transform: translateY(8px); opacity: 0; pointer-events:none; }
    #elevWrap.sheet.open{ height: 28vh; transform: translateY(0); opacity: 1; }
    #elevWrap.sheet.mid{ height: 45vh; }
    #elevWrap.sheet.max{ height: 70vh; }
  }

  /* Desktop: keep it compact at bottom, no drag handle needed (but still works) */
  @media (min-width: 769px){
    #elevWrap.sheet{ display:block; }
    #elevWrap.sheet.closed{ height: 0; transform: translateY(8px); opacity:0; pointer-events:none; }
    #elevWrap.sheet.open{ height: 24vh; }
    #elevWrap.sheet.mid{ height: 34vh; }
    #elevWrap.sheet.max{ height: 46vh; }
  }
</style>
</head>
<body>
<div id="map"></div>

<div class="ui">
  <div class="row">
    <b>BRouter profile</b>
    <select id="profile">
      <option value="hiking">hiking (prefers trails)</option>
      <option value="foot">foot (pedestrian)</option>
      <option value="trekking">trekking (bike/hike mix)</option>
    </select>
    <span id="dist" class="badge">0.00 km</span>
  </div>
  <div class="row">
    <input id="routeName" placeholder="Route name" size="16" />
    <button id="btnGpx">Export GPX</button>
    <button id="btnKml">KML</button>
    <button id="btnGeo">GeoJSON</button>
    <button id="btnClear">Clear</button>
    <span id="status" class="ok">tap to add Start → End → Via… (drag markers; long-press/right-click to remove)</span>
  </div>
</div>

<!-- FAB to toggle elevation -->
<div id="toggleElev" title="Show/hide elevation">⌄</div>

<!-- Elevation bottom sheet -->
<div id="elevWrap" class="sheet closed" aria-hidden="true">
  <div id="elevInner">
    <div id="dragHandle"></div>
    <div id="elevHeader">
      <strong>Elevation</strong>
      <span class="stat" id="statMin">Min: —</span>
      <span class="stat" id="statMax">Max: —</span>
      <span class="stat" id="statGain">Ascent: —</span>
      <span class="stat" id="statLoss">Descent: —</span>

      <label style="margin-left:12px">Smoothing
        <select id="smoothLevel">
          <option value="none">None</option>
          <option value="low" selected>Low</option>
          <option value="med">Medium</option>
          <option value="high">High</option>
        </select>
      </label>

      <span id="elevHint">drag the bar to resize • tap ⌄ to hide</span>
    </div>
    <svg id="elevChart"></svg>
  </div>
</div>

<script>
/* ============== Map ============== */
const map = L.map('map').setView([41.387, 2.170], 12);

// --- Base maps ---
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 20, attribution: '© OpenStreetMap contributors'
});
const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20, attribution: 'Tiles © Esri — Sources: Esri, USGS, IGN, etc.'
});
const esriLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 20, attribution: 'Labels © Esri'
});
const openTopo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
  maxZoom: 17, attribution: '© OpenStreetMap, SRTM — OpenTopoMap (CC-BY-SA)'
});
const cartoDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  maxZoom: 20, attribution: '© OpenStreetMap, © CARTO'
});
osm.addTo(map);

const baseLayers = {
  "OSM Standard": osm,
  "Esri Satellite": esriSat,
  "OpenTopoMap": openTopo,
  "CARTO Dark": cartoDark
};
const overlays = { "Labels (Esri)": esriLabels };

L.control.layers(baseLayers, overlays, { position: 'topright', collapsed: true }).addTo(map);

// Auto-show labels with satellite
map.on('baselayerchange', (e) => {
  if (e.name === 'Esri Satellite' && !map.hasLayer(esriLabels)) esriLabels.addTo(map);
});

const profileSel = document.getElementById('profile');
const distBadge  = document.getElementById('dist');
const statusEl   = document.getElementById('status');
const routeName  = document.getElementById('routeName');
function status(msg, cls='ok'){ statusEl.className = cls; statusEl.textContent = msg; }

/* ============== Waypoints & markers ============== */
let waypoints = [];        // array of L.LatLng
let markersLayer = L.layerGroup().addTo(map);
let routeLayer   = null;   // L.GeoJSON of the route
let currentGeo   = null;   // GeoJSON FeatureCollection of the route

map.on('click', (e)=> addWaypoint(e.latlng));

function addWaypoint(latlng){
  waypoints.push(latlng);
  redrawMarkers();
  if(waypoints.length >= 2) computeRoute();
}

function redrawMarkers(){
  markersLayer.clearLayers();
  waypoints.forEach((ll, idx)=>{
    const label = (idx===0?'Start': (idx===waypoints.length-1?'End':'Via'));
    const m = L.marker(ll, { draggable:true, title:label }).addTo(markersLayer);
    m.bindTooltip(label, {permanent:true, direction:'top', offset:[0,-12]});
    m.on('dragend', (ev)=>{ waypoints[idx] = ev.target.getLatLng(); computeRoute(); });
    m.on('contextmenu', ()=>{ // right-click to remove a waypoint
      waypoints.splice(idx,1);
      redrawMarkers();
      if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; currentGeo = null; }
      hideElevation();
      if(waypoints.length >= 2) computeRoute(); else updateDistance(0);
    });
  });
}

document.getElementById('btnClear').onclick = ()=>{
  waypoints = [];
  redrawMarkers();
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation(true); // force close
  updateDistance(0);
  status('cleared','ok');
};

/* ============== Routing (BRouter first, OSRM foot fallback) ============== */
async function computeRoute(){
  if(routeLayer){ map.removeLayer(routeLayer); routeLayer = null; }
  currentGeo = null;
  hideElevation(); // close while routing
  status('routing with BRouter…','warn');

  try{
    const geo = await fetchBRouterGeoJSON(waypoints, profileSel.value);
    drawRouteGeoJSON(geo);
    status('ok (BRouter)','ok');
    await buildElevation(geo);
  }catch(err){
    console.warn('BRouter failed:', err);
    status('BRouter failed → trying OSRM foot…','warn');
    try{
      const geo = await fetchOSRMFootGeoJSON(waypoints);
      drawRouteGeoJSON(geo);
      status('ok (OSRM foot fallback)','ok');
      await buildElevation(geo);
    }catch(e2){
      console.error('OSRM fallback failed:', e2);
      status('routing failed on all services','err');
    }
  }
}

function encodeLonLats(pts){
  // BRouter expects lon,lat pairs bar-separated
  return pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join('|');
}

async function fetchBRouterGeoJSON(pts, profile){
  const lonlats = encodeLonLats(pts);
  const url = `https://brouter.de/brouter?lonlats=${encodeURIComponent(lonlats)}&profile=${encodeURIComponent(profile)}&alternativeidx=0&format=geojson`;
  const r = await fetch(url, { method:'GET' });
  if(!r.ok) throw new Error('HTTP '+r.status);
  return await r.json(); // FeatureCollection
}

async function fetchOSRMFootGeoJSON(pts){
  const coords = pts.map(ll => `${ll.lng.toFixed(6)},${ll.lat.toFixed(6)}`).join(';');
  const url = `https://routing.openstreetmap.de/routed-foot/route/v1/foot/${coords}?overview=full&geometries=geojson&steps=false&alternatives=false`;
  const r = await fetch(url, { method:'GET' });
  const j = await r.json().catch(()=>null);
  if(!r.ok || !j || !j.routes || !j.routes.length) throw new Error('OSRM foot error');
  const line = j.routes[0].geometry; // GeoJSON LineString
  return { type:'FeatureCollection', features:[{ type:'Feature', properties:{source:'osrm-foot'}, geometry: line }] };
}

/* ============== Draw + distance + fit ============== */
function drawRouteGeoJSON(geo){
  currentGeo = geo;
  if(routeLayer){ map.removeLayer(routeLayer); }
  routeLayer = L.geoJSON(geo, { style: { color:var(--accent), weight:5, opacity:0.95 } }).addTo(map);
  try { map.fitBounds(routeLayer.getBounds(), { padding:[20,20] }); } catch(_) {}
  const merged = mergeToLineString(geo);
  const km = merged ? turf.length(merged, {units:'kilometers'}) : 0;
  updateDistance(km);
}

function mergeToLineString(fc){
  if(!fc || !fc.features) return null;
  const coords = [];
  fc.features.forEach(f=>{
    if(!f.geometry) return;
    if(f.geometry.type==='LineString') coords.push(...f.geometry.coordinates);
    if(f.geometry.type==='MultiLineString') f.geometry.coordinates.forEach(c=>coords.push(...c));
  });
  return coords.length ? { type:'Feature', geometry:{ type:'LineString', coordinates: coords }, properties:{} } : null;
}

function updateDistance(km){
  distBadge.textContent = `${(km||0).toFixed(2)} km`;
}

/* ============== Elevation profile (robust + mobile sheet) ============== */
const elevWrap   = document.getElementById('elevWrap');
const elevChart  = document.getElementById('elevChart');
const statMin    = document.getElementById('statMin');
const statMax    = document.getElementById('statMax');
const statGain   = document.getElementById('statGain');
const statLoss   = document.getElementById('statLoss');
const smoothSel  = document.getElementById('smoothLevel');
const toggleElev = document.getElementById('toggleElev');
const dragHandle = document.getElementById('dragHandle');

function setSheetState(state){ // 'closed' | 'open' | 'mid' | 'max'
  elevWrap.classList.remove('closed','open','mid','max');
  elevWrap.classList.add(state);
  elevWrap.setAttribute('aria-hidden', state==='closed' ? 'true' : 'false');
  toggleElev.textContent = (state==='closed') ? '⌃' : '⌄';
  // Recalculate chart size after transition
  setTimeout(()=>{ renderReflow(); }, 220);
}
function showElevation(initial='open'){
  elevWrap.style.display = 'block';
  setSheetState(initial);
}
function hideElevation(force=false){
  if(force){ setSheetState('closed'); }
  elevChart.innerHTML = '';
}

function renderReflow(){
  // Trigger Leaflet size update and rerender chart at new size
  map.invalidateSize();
  if(current_elev_cache){
    renderElevation(current_elev_cache.latlngs, current_elev_cache.elevs);
  }
}

// FAB toggle
toggleElev.addEventListener('click', ()=>{
  if(elevWrap.classList.contains('closed')){
    setSheetState('open');
  }else{
    setSheetState('closed');
  }
});

// Drag to resize (touch + mouse)
(function enableDrag(){
  let startY=0, startH=0, dragging=false;
  const MIN = 0.15, MID = 0.45, MAX = 0.70; // of viewport height

  function vh(px){ return px / window.innerHeight; }

  function onStart(e){
    dragging = true;
    startY = (e.touches? e.touches[0].clientY : e.clientY);
    startH = elevWrap.getBoundingClientRect().height;
    document.body.style.userSelect = 'none';
    e.preventDefault();
  }
  function onMove(e){
    if(!dragging) return;
    const y = (e.touches? e.touches[0].clientY : e.clientY);
    const dy = startY - y; // drag up => increase
    let newH = startH + dy;
    const minH = MIN * window.innerHeight;
    const maxH = MAX * window.innerHeight;
    newH = Math.max(minH, Math.min(maxH, newH));
    elevWrap.style.height = `${newH}px`;
    elevWrap.classList.add('sheet'); // ensure visible
    elevWrap.classList.remove('closed','open','mid','max');
    e.preventDefault();
    renderReflow();
  }
  function onEnd(){
    if(!dragging) return;
    dragging = false;
    document.body.style.userSelect = '';
    const h = elevWrap.getBoundingClientRect().height;
    const ratio = vh(h);
    // snap to nearest state
    const target = (ratio < (MIN+MID)/2) ? 'open' : (ratio < (MID+MAX)/2 ? 'mid' : 'max');
    setSheetState(target);
    elevWrap.style.height = ''; // return to CSS rule
  }

  dragHandle.addEventListener('mousedown', onStart, {passive:false});
  dragHandle.addEventListener('touchstart', onStart, {passive:false});
  window.addEventListener('mousemove', onMove, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('mouseup', onEnd);
  window.addEventListener('touchend', onEnd);
})();

// simple median filter (odd window)
function medianFilter(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null).sort((x,y)=>x-y);
    out[i] = slice.length ? slice[Math.floor(slice.length/2)] : arr[i];
  }
  return out;
}
// centered moving average (odd window)
function movingAverage(arr, win){
  const k = Math.floor(win/2);
  const out = arr.slice();
  for(let i=0;i<arr.length;i++){
    const a = Math.max(0,i-k), b = Math.min(arr.length-1,i+k);
    const slice = arr.slice(a,b+1).filter(v=>v!=null);
    const sum = slice.reduce((s,v)=>s+v,0);
    out[i] = slice.length ? (sum/slice.length) : arr[i];
  }
  return out;
}
function smoothSeries(raw, level){
  if(level==='none') return raw.slice();
  const cfg = {
    low:  { med:5, avg:7  },
    med:  { med:5, avg:11 },
    high: { med:7, avg:15 }
  }[level] || { med:5, avg:7 };
  const m = medianFilter(raw, cfg.med);
  return movingAverage(m, cfg.avg);
}

smoothSel.addEventListener('change', ()=> {
  if(current_elev_cache){
    renderElevation(current_elev_cache.latlngs, current_elev_cache.elevs); // re-render with new smoothing
  }
});

let current_elev_cache = null;

// Helper: detect if route roughly lies in Europe to pick EU-DEM
function routeInEurope(lineFeature){
  // rough Europe bbox [W,S,E,N]
  const EUROPE_BBOX = [-31.5, 27.5, 45.5, 71.5];
  try {
    const bb = turf.bbox(lineFeature); // [minX, minY, maxX, maxY]
    const cx = (bb[0] + bb[2]) / 2, cy = (bb[1] + bb[3]) / 2;
    return (cx >= EUROPE_BBOX[0] && cx <= EUROPE_BBOX[2] &&
            cy >= EUROPE_BBOX[1] && cy <= EUROPE_BBOX[3]);
  } catch { return false; }
}

async function buildElevation(geo){
  try{
    const line = mergeToLineString(geo);
    if(!line) { setSheetState('closed'); return; }

    const lengthKm = turf.length(line, {units:'kilometers'});

    // modest sampling: ~20 pts/km (cap 250) → fewer rate limits and shorter URLs
    const samples = Math.max(30, Math.min(250, Math.round(lengthKm * 20)));

    const pts = [];
    for (let i=0;i<=samples;i++){
      const seg = turf.along(line, (lengthKm * i / samples), {units:'kilometers'});
      const [x,y] = seg.geometry.coordinates;
      pts.push([y,x]); // lat,lon
    }

    // Choose dataset: EU → eudem25m, otherwise srtm90m
    const dataset = routeInEurope(line) ? 'eudem25m' : 'srtm90m';

    const elevations = await fetchElevationsRobust(pts, dataset);

    if (!elevations || elevations.every(v => v == null)){
      status('Elevation unavailable (all providers failed)', 'warn');
      setSheetState('closed');
      return;
    }

    current_elev_cache = { latlngs: pts, elevs: elevations };
    renderElevation(pts, elevations);

    // Show sheet at a comfortable size (mobile open; desktop open)
    showElevation('open');
  }catch(err){
    console.warn('Elevation failed:', err);
    status('Elevation error (see console)', 'warn');
    setSheetState('closed');
  }
}

// Robust fetch: OpenTopoData first (batched, cubic), fallback to Open-Elevation (batched).
async function fetchElevationsRobust(latlngs, dataset='srtm90m'){
  try {
    const vals = await fetchOpenTopoData(latlngs, dataset);
    if (vals && vals.some(v => v != null)) return vals;
  } catch (e) {
    console.warn('OpenTopoData error:', e);
  }
  try {
    const vals2 = await fetchOpenElevation(latlngs);
    return vals2;
  } catch (e2) {
    console.warn('Open-Elevation error:', e2);
  }
  return new Array(latlngs.length).fill(null);
}

async function fetchOpenTopoData(latlngs, dataset){
  const BATCH = 80; // keep URLs short/reliable
  const out = [];
  for (let i=0; i<latlngs.length; i+=BATCH){
    const chunk = latlngs.slice(i, i+BATCH)
      .map(([lat,lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join('|');
    const url = `https://api.opentopodata.org/v1/${dataset}` +
                `?locations=${encodeURIComponent(chunk)}&interpolation=cubic`;
    const r = await fetch(url);
    const j = await r.json().catch(()=>null);
    if (!r.ok || !j || !j.results) throw new Error(`OpenTopoData ${r.status}`);
    j.results.forEach(res => out.push(res ? res.elevation : null));
  }
  return out;
}

async function fetchOpenElevation(latlngs){
  const BATCH = 100;
  const out = [];
  for (let i=0; i<latlngs.length; i+=BATCH){
    const chunk = latlngs.slice(i, i+BATCH)
      .map(([lat,lon]) => `${lat.toFixed(5)},${lon.toFixed(5)}`).join('|');
    const url = `https://api.open-elevation.com/api/v1/lookup?locations=${encodeURIComponent(chunk)}`;
    const r = await fetch(url);
    const j = await r.json().catch(()=>null);
    if (!r.ok || !j || !j.results) throw new Error(`Open-Elevation ${r.status}`);
    j.results.forEach(res => out.push(res ? res.elevation : null));
  }
  return out;
}

function renderElevation(latlngs, elevsRaw){
  if(!elevsRaw || !elevsRaw.length) return;

  const level = smoothSel.value;
  const elevs = smoothSeries(elevsRaw, level);

  // Compute stats
  let min = Infinity, max = -Infinity, gain = 0, loss = 0;
  for(let i=0;i<elevs.length;i++){
    const z = elevs[i]; if(z==null) continue;
    if(z<min) min = z; if(z>max) max = z;
    if(i>0 && elevs[i-1]!=null){
      const dz = z - elevs[i-1];
      if(dz>0) gain += dz; else loss += -dz;
    }
  }

  statMin.textContent  = `Min: ${Math.round(min)} m`;
  statMax.textContent  = `Max: ${Math.round(max)} m`;
  statGain.textContent = `Ascent: ${Math.round(gain)} m`;
  statLoss.textContent = `Descent: ${Math.round(loss)} m`;

  // Build SVG
  const W = elevChart.clientWidth || 600;
  const H = elevChart.clientHeight || 160;
  const pad = 24;
  const w = W - pad*2;
  const h = H - pad*2;

  const eMin = Math.min(min, max-1);
  const eMax = max;
  const scaleX = (i)=> pad + (i/(elevs.length-1))*w;
  const scaleY = (z)=> pad + h - ((z - eMin) / (eMax - eMin || 1)) * h;

  // Path
  let d = '';
  for(let i=0;i<elevs.length;i++){
    const x = scaleX(i), y = scaleY(elevs[i]);
    d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
  }
  const area = `${d} L ${pad + w} ${pad + h} L ${pad} ${pad + h} Z`;

  // Axis ticks
  const ticks = [eMin, (eMin+eMax)/2, eMax];

  elevChart.innerHTML = `
    <defs>
      <linearGradient id="grad" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()}" stop-opacity="0.35"/>
        <stop offset="100%" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()}" stop-opacity="0.05"/>
      </linearGradient>
    </defs>
    <rect x="0" y="0" width="${W}" height="${H}" fill="transparent"/>
    <path d="${area}" fill="url(#grad)"></path>
    <path d="${d}" fill="none" stroke="${getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()}" stroke-width="2"></path>
    ${ticks.map((t,i)=>{
      const y = scaleY(t);
      return `<line x1="${pad}" y1="${y}" x2="${pad+w}" stroke="#223" stroke-dasharray="3,3"/>
              <text x="${pad-6}" y="${y+4}" text-anchor="end" fill="#9ca3af" font-size="11">${Math.round(t)} m</text>`;
    }).join('')}
  `;

  // Hover tooltip
  const tooltip = document.createElementNS('http://www.w3.org/2000/svg','g');
  const line   = document.createElementNS('http://www.w3.org/2000/svg','line');
  const dot    = document.createElementNS('http://www.w3.org/2000/svg','circle');
  const label  = document.createElementNS('http://www.w3.org/2000/svg','text');
  line.setAttribute('stroke','#93c5fd'); line.setAttribute('y1', pad); line.setAttribute('y2', pad+h);
  dot.setAttribute('r','3'); dot.setAttribute('fill','#93c5fd'); dot.setAttribute('stroke','#111827');
  label.setAttribute('fill','#e5e7eb'); label.setAttribute('font-size','11');
  tooltip.appendChild(line); tooltip.appendChild(dot); tooltip.appendChild(label);
  elevChart.appendChild(tooltip);
  tooltip.style.display = 'none';

  function nearestIndex(mouseX){
    const x = Math.max(pad, Math.min(mouseX, pad+w));
    const ratio = (x - pad)/w;
    return Math.round(ratio * (elevs.length-1));
  }

  function updateTip(evt){
    const rect = elevChart.getBoundingClientRect();
    const x = (evt.touches ? evt.touches[0].clientX : evt.clientX) - rect.left;
    const i = nearestIndex(x);
    const xi = scaleX(i), yi = scaleY(elevs[i]);
    tooltip.style.display = '';
    line.setAttribute('x1', xi); line.setAttribute('x2', xi);
    dot.setAttribute('cx', xi);  dot.setAttribute('cy', yi);
    label.setAttribute('x', xi+6); label.setAttribute('y', yi-8);
    const distTotal = turf.length(mergeToLineString(currentGeo), {units:'kilometers'}) || 0;
    const distAt = (distTotal * (i/(elevs.length-1)));
    label.textContent = `${Math.round(elevs[i])} m @ ${distAt.toFixed(2)} km`;
  }

  elevChart.onmousemove = updateTip;
  elevChart.ontouchstart = updateTip;
  elevChart.ontouchmove = updateTip;
  elevChart.onmouseleave = ()=>{ tooltip.style.display = 'none'; };
}

/* ============== Profile change triggers re-route ============== */
profileSel.addEventListener('change', ()=>{ if(waypoints.length>=2) computeRoute(); });

/* ============== Exporters ============== */
const btnGpx = document.getElementById('btnGpx');
const btnKml = document.getElementById('btnKml');
const btnGeo = document.getElementById('btnGeo');

btnGeo.addEventListener('click', ()=>{
  if(!currentGeo){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.geojson';
  download(name, JSON.stringify(currentGeo, null, 2), 'application/geo+json');
});

btnGpx.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.gpx';
  const gpx = toGPX(line, current_elev_cache);
  download(name, gpx, 'application/gpx+xml');
});

btnKml.addEventListener('click', ()=>{
  const line = mergeToLineString(currentGeo || {});
  if(!line){ alert('No route to export'); return; }
  const name = (routeName.value || 'route') + '.kml';
  const kml = toKML(line, current_elev_cache);
  download(name, kml, 'application/vnd.google-earth.kml+xml');
});

function download(filename, data, mime='application/octet-stream'){
  const blob = new Blob([data], {type:mime});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

function toGPX(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    elevs = resampleArray(elevCache.elevs, coords.length); // resample to match
  }
  const name = escapeXml(routeName.value || 'Route');
  const trkpts = coords.map((c,i)=>{
    const lon = c[0].toFixed(6), lat = c[1].toFixed(6);
    const ele = elevs ? `<ele>${Number(elevs[i]).toFixed(1)}</ele>` : '';
    return `<trkpt lat="${lat}" lon="${lon}">${ele}</trkpt>`;
  }).join('');
  return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Leaflet+BRouter" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><name>${name}</name></metadata>
  <trk><name>${name}</name><trkseg>${trkpts}</trkseg></trk>
</gpx>`;
}

function toKML(lineFeature, elevCache){
  const coords = lineFeature.geometry.coordinates; // [lon,lat]
  let elevs = null;
  if(elevCache && Array.isArray(elevCache.elevs) && elevCache.elevs.length){
    elevs = resampleArray(elevCache.elevs, coords.length);
  }
  const name = escapeXml(routeName.value || 'Route');
  const coordStr = coords.map((c,i)=>{
    const z = elevs ? Number(elevs[i]).toFixed(1) : '0';
    return `${c[0].toFixed(6)},${c[1].toFixed(6)},${z}`;
  }).join(' ');
  return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Placemark>
      <name>${name}</name>
      <Style><LineStyle><color>ff55c522</color><width>4</width></LineStyle></Style>
      <LineString><tessellate>1</tessellate><coordinates>${coordStr}</coordinates></LineString>
    </Placemark>
  </Document>
</kml>`;
}

function resampleArray(arr, n){
  // simple linear resample from arr.length -> n
  const out = new Array(n);
  const m = arr.length;
  for(let i=0;i<n;i++){
    const t = (i*(m-1))/(n-1);
    const i0 = Math.floor(t), i1 = Math.min(m-1, i0+1);
    const a = arr[i0], b = arr[i1];
    const frac = t - i0;
    out[i] = a + (b - a) * frac;
  }
  return out;
}

function escapeXml(s){ return String(s).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c])); }

/* ===== Elevation helpers (already defined in previous sections) ===== */

</script>
</body>
</html>
